# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/backports.functools_lru_cache-1.4/backports/functools_lru_cache.py
from __future__ import absolute_import
import functools
from collections import namedtuple
from threading import RLock
_CacheInfo = namedtuple('CacheInfo', ['hits',
 'misses',
 'maxsize',
 'currsize'])

@functools.wraps(functools.update_wrapper)
def update_wrapper(wrapper, wrapped, assigned=functools.WRAPPER_ASSIGNMENTS, updated=functools.WRAPPER_UPDATES):
    assigned = tuple((attr for attr in assigned if hasattr(wrapped, attr)))
    wrapper = functools.update_wrapper(wrapper, wrapped, assigned, updated)
    wrapper.__wrapped__ = wrapped
    return wrapper


class _HashedSeq(list):
    __slots__ = 'hashvalue'

    def __init__(self, tup, hash=hash):
        self[:] = tup
        self.hashvalue = hash(tup)

    def __hash__(self):
        return self.hashvalue


def _make_key(args, kwds, typed, kwd_mark=(object(),), fasttypes=set([int,
 str,
 frozenset,
 type(None)]), sorted=sorted, tuple=tuple, type=type, len=len):
    key = args
    if kwds:
        sorted_items = sorted(kwds.items())
        key += kwd_mark
        for item in sorted_items:
            key += item

    if typed:
        key += tuple((type(v) for v in args))
        if kwds:
            key += tuple((type(v) for k, v in sorted_items))
    elif len(key) == 1 and type(key[0]) in fasttypes:
        return key[0]
    return _HashedSeq(key)


def lru_cache(maxsize=100, typed=False):

    def decorating_function(user_function):
        cache = dict()
        stats = [0, 0]
        HITS, MISSES = (0, 1)
        make_key = _make_key
        cache_get = cache.get
        _len = len
        lock = RLock()
        root = []
        root[:] = [root,
         root,
         None,
         None]
        nonlocal_root = [root]
        PREV, NEXT, KEY, RESULT = (0, 1, 2, 3)
        if maxsize == 0:

            def wrapper(*args, **kwds):
                result = user_function(*args, **kwds)
                stats[MISSES] += 1
                return result

        elif maxsize is None:

            def wrapper(*args, **kwds):
                key = make_key(args, kwds, typed)
                result = cache_get(key, root)
                if result is not root:
                    stats[HITS] += 1
                    return result
                result = user_function(*args, **kwds)
                cache[key] = result
                stats[MISSES] += 1
                return result

        else:

            def wrapper(*args, **kwds):
                key = make_key(args, kwds, typed) if kwds or typed else args
                with lock:
                    link = cache_get(key)
                    if link is not None:
                        root = nonlocal_root
                        link_prev, link_next, key, result = link
                        link_prev[NEXT] = link_next
                        link_next[PREV] = link_prev
                        last = root[PREV]
                        last[NEXT] = root[PREV] = link
                        link[PREV] = last
                        link[NEXT] = root
                        stats[HITS] += 1
                        return result
                result = user_function(*args, **kwds)
                with lock:
                    root = nonlocal_root
                    if key in cache:
                        pass
                    elif _len(cache) >= maxsize:
                        oldroot = root
                        oldroot[KEY] = key
                        oldroot[RESULT] = result
                        root = nonlocal_root[0] = oldroot[NEXT]
                        oldkey = root[KEY]
                        root[KEY] = root[RESULT] = None
                        del cache[oldkey]
                        cache[key] = oldroot
                    else:
                        last = root[PREV]
                        link = [last,
                         root,
                         key,
                         result]
                        last[NEXT] = root[PREV] = cache[key] = link
                    stats[MISSES] += 1
                return result

        def cache_info():
            with lock:
                return _CacheInfo(stats[HITS], stats[MISSES], maxsize, len(cache))

        def cache_clear():
            with lock:
                cache.clear()
                root = nonlocal_root[0]
                root[:] = [root,
                 root,
                 None,
                 None]
                stats[:] = [0, 0]
            return

        wrapper.__wrapped__ = user_function
        wrapper.cache_info = cache_info
        wrapper.cache_clear = cache_clear
        return update_wrapper(wrapper, user_function)

    return decorating_function
