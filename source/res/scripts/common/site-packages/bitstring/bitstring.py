# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/bitstring/bitstring.py
__licence__ = '\nThe MIT License\n\nCopyright (c) 2006-2016 Scott Griffiths (dr.scottgriffiths@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n'
__version__ = '3.1.5'
__author__ = 'Scott Griffiths'
import numbers
import copy
import sys
import re
import binascii
import mmap
import os
import struct
import operator
import collections
import array
byteorder = sys.byteorder
bytealigned = False
MAX_CHARS = 250
CACHE_SIZE = 1000

class Error(Exception):

    def __init__(self, *params):
        self.msg = params[0] if params else ''
        self.params = params[1:]

    def __str__(self):
        return self.msg.format(*self.params) if self.params else self.msg


class ReadError(Error, IndexError):

    def __init__(self, *params):
        Error.__init__(self, *params)


class InterpretError(Error, ValueError):

    def __init__(self, *params):
        Error.__init__(self, *params)


class ByteAlignError(Error):

    def __init__(self, *params):
        Error.__init__(self, *params)


class CreationError(Error, ValueError):

    def __init__(self, *params):
        Error.__init__(self, *params)


class ConstByteStore(object):
    __slots__ = ('offset', '_rawarray', 'bitlength')

    def __init__(self, data, bitlength=None, offset=None):
        self._rawarray = data
        if offset is None:
            offset = 0
        if bitlength is None:
            bitlength = 8 * len(data) - offset
        self.offset = offset
        self.bitlength = bitlength
        return

    def getbit(self, pos):
        byte, bit = divmod(self.offset + pos, 8)
        return bool(self._rawarray[byte] & 128 >> bit)

    def getbyte(self, pos):
        return self._rawarray[pos]

    def getbyteslice(self, start, end):
        c = self._rawarray[start:end]
        return c

    @property
    def bytelength(self):
        if not self.bitlength:
            return 0
        sb = self.offset // 8
        eb = (self.offset + self.bitlength - 1) // 8
        return eb - sb + 1

    def __copy__(self):
        return ByteStore(self._rawarray[:], self.bitlength, self.offset)

    def _appendstore(self, store):
        if not store.bitlength:
            return
        store = offsetcopy(store, (self.offset + self.bitlength) % 8)
        if store.offset:
            joinval = self._rawarray.pop() & (255 ^ 255 >> store.offset) | store.getbyte(0) & 255 >> store.offset
            self._rawarray.append(joinval)
            self._rawarray.extend(store._rawarray[1:])
        else:
            self._rawarray.extend(store._rawarray)
        self.bitlength += store.bitlength

    def _prependstore(self, store):
        if not store.bitlength:
            return
        store = offsetcopy(store, (self.offset - store.bitlength) % 8)
        bit_offset = self.offset % 8
        if bit_offset:
            store.setbyte(-1, store.getbyte(-1) & (255 ^ 255 >> bit_offset) | self._rawarray[self.byteoffset] & 255 >> bit_offset)
            store._rawarray.extend(self._rawarray[self.byteoffset + 1:self.byteoffset + self.bytelength])
        else:
            store._rawarray.extend(self._rawarray[self.byteoffset:self.byteoffset + self.bytelength])
        self._rawarray = store._rawarray
        self.offset = store.offset
        self.bitlength += store.bitlength

    @property
    def byteoffset(self):
        return self.offset // 8

    @property
    def rawbytes(self):
        return self._rawarray


class ByteStore(ConstByteStore):
    __slots__ = ()

    def setbit(self, pos):
        byte, bit = divmod(self.offset + pos, 8)
        self._rawarray[byte] |= 128 >> bit

    def unsetbit(self, pos):
        byte, bit = divmod(self.offset + pos, 8)
        self._rawarray[byte] &= ~(128 >> bit)

    def invertbit(self, pos):
        byte, bit = divmod(self.offset + pos, 8)
        self._rawarray[byte] ^= 128 >> bit

    def setbyte(self, pos, value):
        self._rawarray[pos] = value

    def setbyteslice(self, start, end, value):
        self._rawarray[start:end] = value


def offsetcopy(s, newoffset):
    if not s.bitlength:
        return copy.copy(s)
    elif newoffset == s.offset % 8:
        return ByteStore(s.getbyteslice(s.byteoffset, s.byteoffset + s.bytelength), s.bitlength, newoffset)
    else:
        newdata = []
        d = s._rawarray
        if newoffset < s.offset % 8:
            shiftleft = s.offset % 8 - newoffset
            for x in range(s.byteoffset, s.byteoffset + s.bytelength - 1):
                newdata.append((d[x] << shiftleft & 255) + (d[x + 1] >> 8 - shiftleft))

            bits_in_last_byte = (s.offset + s.bitlength) % 8
            if not bits_in_last_byte:
                bits_in_last_byte = 8
            if bits_in_last_byte > shiftleft:
                newdata.append(d[s.byteoffset + s.bytelength - 1] << shiftleft & 255)
        else:
            shiftright = newoffset - s.offset % 8
            newdata.append(s.getbyte(0) >> shiftright)
            for x in range(s.byteoffset + 1, s.byteoffset + s.bytelength):
                newdata.append((d[x - 1] << 8 - shiftright & 255) + (d[x] >> shiftright))

            bits_in_last_byte = (s.offset + s.bitlength) % 8
            if not bits_in_last_byte:
                bits_in_last_byte = 8
            if bits_in_last_byte + shiftright > 8:
                newdata.append(d[s.byteoffset + s.bytelength - 1] << 8 - shiftright & 255)
        new_s = ByteStore(bytearray(newdata), s.bitlength, newoffset)
        return new_s


def equal(a, b):
    a_bitlength = a.bitlength
    b_bitlength = b.bitlength
    if a_bitlength != b_bitlength:
        return False
    if not a_bitlength:
        return True
    if a.offset % 8 > b.offset % 8:
        a, b = b, a
    a_bitoff = a.offset % 8
    b_bitoff = b.offset % 8
    a_byteoffset = a.byteoffset
    b_byteoffset = b.byteoffset
    a_bytelength = a.bytelength
    b_bytelength = b.bytelength
    da = a._rawarray
    db = b._rawarray
    if da is db and a.offset == b.offset:
        return True
    if a_bitoff == b_bitoff:
        bits_spare_in_last_byte = 8 - (a_bitoff + a_bitlength) % 8
        if bits_spare_in_last_byte == 8:
            bits_spare_in_last_byte = 0
        if a_bytelength == 1:
            a_val = (da[a_byteoffset] << a_bitoff & 255) >> 8 - a_bitlength
            b_val = (db[b_byteoffset] << b_bitoff & 255) >> 8 - b_bitlength
            return a_val == b_val
        if da[a_byteoffset] & 255 >> a_bitoff != db[b_byteoffset] & 255 >> b_bitoff:
            return False
        b_a_offset = b_byteoffset - a_byteoffset
        for x in range(1 + a_byteoffset, a_byteoffset + a_bytelength - 1):
            if da[x] != db[b_a_offset + x]:
                return False

        return da[a_byteoffset + a_bytelength - 1] >> bits_spare_in_last_byte == db[b_byteoffset + b_bytelength - 1] >> bits_spare_in_last_byte
    shift = b_bitoff - a_bitoff
    if b_bytelength == 1:
        a_val = (da[a_byteoffset] << a_bitoff & 255) >> 8 - a_bitlength
        b_val = (db[b_byteoffset] << b_bitoff & 255) >> 8 - b_bitlength
        return a_val == b_val
    if a_bytelength == 1:
        a_val = (da[a_byteoffset] << a_bitoff & 255) >> 8 - a_bitlength
        b_val = (db[b_byteoffset] << 8) + db[b_byteoffset + 1] << b_bitoff
        b_val &= 65535
        b_val >>= 16 - b_bitlength
        return a_val == b_val
    if (da[a_byteoffset] & 255 >> a_bitoff) >> shift != db[b_byteoffset] & 255 >> b_bitoff:
        return False
    for x in range(1, b_bytelength - 1):
        b_val = db[b_byteoffset + x]
        a_val = (da[a_byteoffset + x - 1] << 8) + da[a_byteoffset + x] >> shift
        a_val &= 255
        if a_val != b_val:
            return False

    final_b_bits = (b.offset + b_bitlength) % 8
    if not final_b_bits:
        final_b_bits = 8
    b_val = db[b_byteoffset + b_bytelength - 1] >> 8 - final_b_bits
    final_a_bits = (a.offset + a_bitlength) % 8
    if not final_a_bits:
        final_a_bits = 8
    if b.bytelength > a_bytelength:
        a_val = da[a_byteoffset + a_bytelength - 1] >> 8 - final_a_bits
        a_val &= 255 >> 8 - final_b_bits
        return a_val == b_val
    a_val = da[a_byteoffset + a_bytelength - 2] << 8
    a_val += da[a_byteoffset + a_bytelength - 1]
    a_val >>= 8 - final_a_bits
    a_val &= 255 >> 8 - final_b_bits
    return a_val == b_val


class MmapByteArray(object):
    __slots__ = ('filemap', 'filelength', 'source', 'byteoffset', 'bytelength')

    def __init__(self, source, bytelength=None, byteoffset=None):
        self.source = source
        source.seek(0, os.SEEK_END)
        self.filelength = source.tell()
        if byteoffset is None:
            byteoffset = 0
        if bytelength is None:
            bytelength = self.filelength - byteoffset
        self.byteoffset = byteoffset
        self.bytelength = bytelength
        self.filemap = mmap.mmap(source.fileno(), 0, access=mmap.ACCESS_READ)
        return

    def __getitem__(self, key):
        try:
            start = key.start
            stop = key.stop
        except AttributeError:
            try:
                return ord(self.filemap[key + self.byteoffset])
            except TypeError:
                return self.filemap[key + self.byteoffset]

        else:
            if start is None:
                start = 0
            if stop is None:
                stop = self.bytelength
            s = slice(start + self.byteoffset, stop + self.byteoffset)
            return bytearray(self.filemap.__getitem__(s))

        return

    def __len__(self):
        return self.bytelength


BYTE_REVERSAL_DICT = dict()
try:
    xrange
    for i in range(256):
        BYTE_REVERSAL_DICT[i] = chr(int('{0:08b}'.format(i)[::-1], 2))

except NameError:
    for i in range(256):
        BYTE_REVERSAL_DICT[i] = bytes([int('{0:08b}'.format(i)[::-1], 2)])

    from io import IOBase as file
    xrange = range
    basestring = str

LEADING_OCT_CHARS = len(oct(1)) - 1

def tidy_input_string(s):
    s = ''.join(s.split()).lower()
    return s


INIT_NAMES = ('uint',
 'int',
 'ue',
 'se',
 'sie',
 'uie',
 'hex',
 'oct',
 'bin',
 'bits',
 'uintbe',
 'intbe',
 'uintle',
 'intle',
 'uintne',
 'intne',
 'float',
 'floatbe',
 'floatle',
 'floatne',
 'bytes',
 'bool',
 'pad')
TOKEN_RE = re.compile('(?P<name>' + '|'.join(INIT_NAMES) + ')((:(?P<len>[^=]+)))?(=(?P<value>.*))?$', re.IGNORECASE)
DEFAULT_UINT = re.compile('(?P<len>[^=]+)?(=(?P<value>.*))?$', re.IGNORECASE)
MULTIPLICATIVE_RE = re.compile('(?P<factor>.*)\\*(?P<token>.+)')
LITERAL_RE = re.compile('(?P<name>0(x|o|b))(?P<value>.+)', re.IGNORECASE)
STRUCT_PACK_RE = re.compile('(?P<endian><|>|@)?(?P<fmt>(?:\\d*[bBhHlLqQfd])+)$')
STRUCT_SPLIT_RE = re.compile('\\d*[bBhHlLqQfd]')
REPLACEMENTS_BE = {'b': 'intbe:8',
 'B': 'uintbe:8',
 'h': 'intbe:16',
 'H': 'uintbe:16',
 'l': 'intbe:32',
 'L': 'uintbe:32',
 'q': 'intbe:64',
 'Q': 'uintbe:64',
 'f': 'floatbe:32',
 'd': 'floatbe:64'}
REPLACEMENTS_LE = {'b': 'intle:8',
 'B': 'uintle:8',
 'h': 'intle:16',
 'H': 'uintle:16',
 'l': 'intle:32',
 'L': 'uintle:32',
 'q': 'intle:64',
 'Q': 'uintle:64',
 'f': 'floatle:32',
 'd': 'floatle:64'}
PACK_CODE_SIZE = {'b': 1,
 'B': 1,
 'h': 2,
 'H': 2,
 'l': 4,
 'L': 4,
 'q': 8,
 'Q': 8,
 'f': 4,
 'd': 8}
_tokenname_to_initialiser = {'hex': 'hex',
 '0x': 'hex',
 '0X': 'hex',
 'oct': 'oct',
 '0o': 'oct',
 '0O': 'oct',
 'bin': 'bin',
 '0b': 'bin',
 '0B': 'bin',
 'bits': 'auto',
 'bytes': 'bytes',
 'pad': 'pad'}

def structparser(token):
    m = STRUCT_PACK_RE.match(token)
    if not m:
        return [token]
    else:
        endian = m.group('endian')
        if endian is None:
            return [token]
        formatlist = re.findall(STRUCT_SPLIT_RE, m.group('fmt'))
        fmt = ''.join([ (f[-1] * int(f[:-1]) if len(f) != 1 else f) for f in formatlist ])
        if endian == '@':
            if byteorder == 'little':
                endian = '<'
            else:
                endian = '>'
        if endian == '<':
            tokens = [ REPLACEMENTS_LE[c] for c in fmt ]
        else:
            tokens = [ REPLACEMENTS_BE[c] for c in fmt ]
        return tokens


def tokenparser(fmt, keys=None, token_cache={}):
    try:
        return token_cache[fmt, keys]
    except KeyError:
        token_key = (fmt, keys)

    fmt = expand_brackets(fmt)
    meta_tokens = (''.join(f.split()) for f in fmt.split(','))
    return_values = []
    stretchy_token = False
    for meta_token in meta_tokens:
        m = MULTIPLICATIVE_RE.match(meta_token)
        if not m:
            factor = 1
        else:
            factor = int(m.group('factor'))
            meta_token = m.group('token')
        tokens = structparser(meta_token)
        ret_vals = []
        for token in tokens:
            if keys and token in keys:
                ret_vals.append([token, None, None])
                continue
            value = length = None
            if token == '':
                continue
            m = LITERAL_RE.match(token)
            if m:
                name = m.group('name')
                value = m.group('value')
                ret_vals.append([name, length, value])
                continue
            m1 = TOKEN_RE.match(token)
            if not m1:
                m2 = DEFAULT_UINT.match(token)
                if not m2:
                    raise ValueError("Don't understand token '{0}'.".format(token))
            if m1:
                name = m1.group('name')
                length = m1.group('len')
                if m1.group('value'):
                    value = m1.group('value')
            else:
                name = 'uint'
                length = m2.group('len')
                if m2.group('value'):
                    value = m2.group('value')
            if name == 'bool':
                if length is not None:
                    raise ValueError("You can't specify a length with bool tokens - they are always one bit.")
                length = 1
            if length is None and name not in ('se', 'ue', 'sie', 'uie'):
                stretchy_token = True
            if length is not None:
                try:
                    length = int(length)
                    if length < 0:
                        raise Error
                    if name == 'bytes':
                        length *= 8
                except Error:
                    raise ValueError("Can't read a token with a negative length.")
                except ValueError:
                    if not keys or length not in keys:
                        raise ValueError("Don't understand length '{0}' of token.".format(length))

            ret_vals.append([name, length, value])

        return_values.extend(ret_vals * factor)

    return_values = [ tuple(x) for x in return_values ]
    if len(token_cache) < CACHE_SIZE:
        token_cache[token_key] = (stretchy_token, return_values)
    return (stretchy_token, return_values)


BRACKET_RE = re.compile('(?P<factor>\\d+)\\*\\(')

def expand_brackets(s):
    s = ''.join(s.split())
    while True:
        start = s.find('(')
        if start == -1:
            break
        count = 1
        p = start + 1
        while p < len(s):
            if s[p] == '(':
                count += 1
            if s[p] == ')':
                count -= 1
            if not count:
                break
            p += 1

        if count:
            raise ValueError("Unbalanced parenthesis in '{0}'.".format(s))
        if start == 0 or s[start - 1] != '*':
            s = s[0:start] + s[start + 1:p] + s[p + 1:]
        m = BRACKET_RE.search(s)
        if m:
            factor = int(m.group('factor'))
            matchstart = m.start('factor')
            s = s[0:matchstart] + (factor - 1) * (s[start + 1:p] + ',') + s[start + 1:p] + s[p + 1:]
        raise ValueError("Failed to parse '{0}'.".format(s))

    return s


OCT_TO_BITS = [ '{0:03b}'.format(i) for i in xrange(8) ]
BIT_COUNT = dict(zip(xrange(256), [ bin(i).count('1') for i in xrange(256) ]))

class Bits(object):
    __slots__ = '_datastore'

    def __init__(self, auto=None, length=None, offset=None, **kwargs):
        pass

    def __new__(cls, auto=None, length=None, offset=None, _cache={}, **kwargs):
        try:
            if isinstance(auto, basestring):
                try:
                    return _cache[auto]
                except KeyError:
                    x = object.__new__(Bits)
                    try:
                        _, tokens = tokenparser(auto)
                    except ValueError as e:
                        raise CreationError(*e.args)

                    x._datastore = ConstByteStore(bytearray(0), 0, 0)
                    for token in tokens:
                        x._datastore._appendstore(Bits._init_with_token(*token)._datastore)

                    if len(_cache) < CACHE_SIZE:
                        _cache[auto] = x
                    return x

            if type(auto) == Bits:
                return auto
        except TypeError:
            pass

        x = super(Bits, cls).__new__(cls)
        x._initialise(auto, length, offset, **kwargs)
        return x

    def _initialise(self, auto, length, offset, **kwargs):
        if length is not None and length < 0:
            raise CreationError('bitstring length cannot be negative.')
        if offset is not None and offset < 0:
            raise CreationError('offset must be >= 0.')
        if auto is not None:
            self._initialise_from_auto(auto, length, offset)
            return
        elif not kwargs:
            if length is not None and length != 0:
                data = bytearray((length + 7) // 8)
                self._setbytes_unsafe(data, length, 0)
                return
            self._setbytes_unsafe(bytearray(0), 0, 0)
            return
        else:
            k, v = kwargs.popitem()
            try:
                init_without_length_or_offset[k](self, v)
                if length is not None or offset is not None:
                    raise CreationError('Cannot use length or offset with this initialiser.')
            except KeyError:
                try:
                    init_with_length_only[k](self, v, length)
                    if offset is not None:
                        raise CreationError('Cannot use offset with this initialiser.')
                except KeyError:
                    if offset is None:
                        offset = 0
                    try:
                        init_with_length_and_offset[k](self, v, length, offset)
                    except KeyError:
                        raise CreationError("Unrecognised keyword '{0}' used to initialise.", k)

            return

    def _initialise_from_auto(self, auto, length, offset):
        if offset is None:
            offset = 0
        self._setauto(auto, length, offset)
        return

    def __copy__(self):
        return self

    def __lt__(self, other):
        raise TypeError('unorderable type: {0}'.format(type(self).__name__))

    def __gt__(self, other):
        raise TypeError('unorderable type: {0}'.format(type(self).__name__))

    def __le__(self, other):
        raise TypeError('unorderable type: {0}'.format(type(self).__name__))

    def __ge__(self, other):
        raise TypeError('unorderable type: {0}'.format(type(self).__name__))

    def __add__(self, bs):
        bs = Bits(bs)
        if bs.len <= self.len:
            s = self._copy()
            s._append(bs)
        else:
            s = bs._copy()
            s = self.__class__(s)
            s._prepend(self)
        return s

    def __radd__(self, bs):
        bs = self._converttobitstring(bs)
        return bs.__add__(self)

    def __getitem__(self, key):
        length = self.len
        try:
            step = key.step if key.step is not None else 1
        except AttributeError:
            if key < 0:
                key += length
            if not 0 <= key < length:
                raise IndexError('Slice index out of range.')
            return self._datastore.getbit(key)

        if step != 1:
            bs = self.__class__()
            bs._setbin_unsafe(self._getbin().__getitem__(key))
            return bs
        else:
            start, stop = 0, length
            if key.start is not None:
                start = key.start
                if key.start < 0:
                    start += stop
            if key.stop is not None:
                stop = key.stop
                if key.stop < 0:
                    stop += length
            start = max(start, 0)
            stop = min(stop, length)
            if start < stop:
                return self._slice(start, stop)
            return self.__class__()
            return

    def __len__(self):
        return self._getlength()

    def __str__(self):
        length = self.len
        if not length:
            return ''
        if length > MAX_CHARS * 4:
            return ''.join(('0x', self._readhex(MAX_CHARS * 4, 0), '...'))
        if length < 32 and length % 4 != 0:
            return '0b' + self.bin
        if not length % 4:
            return '0x' + self.hex
        bits_at_end = length % 4
        return ''.join(('0x',
         self._readhex(length - bits_at_end, 0),
         ', ',
         '0b',
         self._readbin(bits_at_end, length - bits_at_end)))

    def __repr__(self):
        length = self.len
        if isinstance(self._datastore._rawarray, MmapByteArray):
            offsetstring = ''
            if self._datastore.byteoffset or self._offset:
                offsetstring = ', offset=%d' % (self._datastore._rawarray.byteoffset * 8 + self._offset)
            lengthstring = ', length=%d' % length
            return "{0}(filename='{1}'{2}{3})".format(self.__class__.__name__, self._datastore._rawarray.source.name, lengthstring, offsetstring)
        else:
            s = self.__str__()
            lengthstring = ''
            if s.endswith('...'):
                lengthstring = ' # length={0}'.format(length)
            return "{0}('{1}'){2}".format(self.__class__.__name__, s, lengthstring)

    def __eq__(self, bs):
        try:
            bs = Bits(bs)
        except TypeError:
            return False

        return equal(self._datastore, bs._datastore)

    def __ne__(self, bs):
        return not self.__eq__(bs)

    def __invert__(self):
        if not self.len:
            raise Error('Cannot invert empty bitstring.')
        s = self._copy()
        s._invert_all()
        return s

    def __lshift__(self, n):
        if n < 0:
            raise ValueError('Cannot shift by a negative amount.')
        if not self.len:
            raise ValueError('Cannot shift an empty bitstring.')
        n = min(n, self.len)
        s = self._slice(n, self.len)
        s._append(Bits(n))
        return s

    def __rshift__(self, n):
        if n < 0:
            raise ValueError('Cannot shift by a negative amount.')
        if not self.len:
            raise ValueError('Cannot shift an empty bitstring.')
        if not n:
            return self._copy()
        s = self.__class__(length=min(n, self.len))
        s._append(self[:-n])
        return s

    def __mul__(self, n):
        if n < 0:
            raise ValueError('Cannot multiply by a negative integer.')
        if not n:
            return self.__class__()
        s = self._copy()
        s._imul(n)
        return s

    def __rmul__(self, n):
        return self.__mul__(n)

    def __and__(self, bs):
        bs = Bits(bs)
        if self.len != bs.len:
            raise ValueError('Bitstrings must have the same length for & operator.')
        s = self._copy()
        s._iand(bs)
        return s

    def __rand__(self, bs):
        return self.__and__(bs)

    def __or__(self, bs):
        bs = Bits(bs)
        if self.len != bs.len:
            raise ValueError('Bitstrings must have the same length for | operator.')
        s = self._copy()
        s._ior(bs)
        return s

    def __ror__(self, bs):
        return self.__or__(bs)

    def __xor__(self, bs):
        bs = Bits(bs)
        if self.len != bs.len:
            raise ValueError('Bitstrings must have the same length for ^ operator.')
        s = self._copy()
        s._ixor(bs)
        return s

    def __rxor__(self, bs):
        return self.__xor__(bs)

    def __contains__(self, bs):
        try:
            pos = self._pos
        except AttributeError:
            pass

        found = Bits.find(self, bs, bytealigned=False)
        try:
            self._pos = pos
        except AttributeError:
            pass

        return bool(found)

    def __hash__(self):
        if self.len <= 160:
            shorter = self
        else:
            shorter = self[:80] + self[-80:]
        h = 0
        for byte in shorter.tobytes():
            try:
                h = (h << 4) + ord(byte)
            except TypeError:
                h = (h << 4) + byte

            g = h & 4026531840L
            if g & 2147483648L:
                h ^= g >> 24
                h ^= g

        return h % 1442968193

    def __nonzero__(self):
        return self.any(True)

    __bool__ = __nonzero__

    def _assertsanity(self):
        return True

    @classmethod
    def _init_with_token(cls, name, token_length, value):
        if token_length is not None:
            token_length = int(token_length)
        if token_length == 0:
            return cls()
        elif name == 'pad':
            return cls(token_length)
        else:
            if value is None:
                if token_length is None:
                    error = 'Token has no value ({0}=???).'.format(name)
                else:
                    error = 'Token has no value ({0}:{1}=???).'.format(name, token_length)
                raise ValueError(error)
            try:
                b = cls(**{_tokenname_to_initialiser[name]: value})
            except KeyError:
                if name in ('se', 'ue', 'sie', 'uie'):
                    b = cls(**{name: int(value)})
                elif name in ('uint', 'int', 'uintbe', 'intbe', 'uintle', 'intle', 'uintne', 'intne'):
                    b = cls(**{name: int(value),
                     'length': token_length})
                elif name in ('float', 'floatbe', 'floatle', 'floatne'):
                    b = cls(**{name: float(value),
                     'length': token_length})
                elif name == 'bool':
                    if value in (1, 'True', '1'):
                        b = cls(bool=True)
                    elif value in (0, 'False', '0'):
                        b = cls(bool=False)
                    else:
                        raise CreationError("bool token can only be 'True' or 'False'.")
                else:
                    raise CreationError("Can't parse token name {0}.", name)

            if token_length is not None and b.len != token_length:
                msg = 'Token with length {0} packed with value of length {1} ({2}:{3}={4}).'
                raise CreationError(msg, token_length, b.len, name, token_length, value)
            return b

    def _clear(self):
        self._datastore = ByteStore(bytearray(0))

    def _setauto(self, s, length, offset):
        if isinstance(s, Bits):
            if length is None:
                length = s.len - offset
            self._setbytes_unsafe(s._datastore.rawbytes, length, s._offset + offset)
            return
        elif isinstance(s, file):
            if offset is None:
                offset = 0
            if length is None:
                length = os.path.getsize(s.name) * 8 - offset
            byteoffset, offset = divmod(offset, 8)
            bytelength = (length + byteoffset * 8 + offset + 7) // 8 - byteoffset
            m = MmapByteArray(s, bytelength, byteoffset)
            if length + byteoffset * 8 + offset > m.filelength * 8:
                raise CreationError('File is not long enough for specified length and offset.')
            self._datastore = ConstByteStore(m, length, offset)
            return
        else:
            if length is not None:
                raise CreationError("The length keyword isn't applicable to this initialiser.")
            if offset:
                raise CreationError("The offset keyword isn't applicable to this initialiser.")
            if isinstance(s, basestring):
                bs = self._converttobitstring(s)
                self._setbytes_unsafe(bs._datastore.rawbytes, bs.length, 0)
                return
            elif isinstance(s, (bytes, bytearray)):
                self._setbytes_unsafe(bytearray(s), len(s) * 8, 0)
                return
            elif isinstance(s, array.array):
                b = s.tostring()
                self._setbytes_unsafe(bytearray(b), len(b) * 8, 0)
                return
            elif isinstance(s, numbers.Integral):
                if s < 0:
                    msg = "Can't create bitstring of negative length {0}."
                    raise CreationError(msg, s)
                data = bytearray((s + 7) // 8)
                self._datastore = ByteStore(data, s, 0)
                return
            elif isinstance(s, collections.Iterable):
                self._setbin_unsafe(''.join((str(int(bool(x))) for x in s)))
                return
            raise TypeError('Cannot initialise bitstring from {0}.'.format(type(s)))
            return

    def _setfile(self, filename, length, offset):
        source = open(filename, 'rb')
        if offset is None:
            offset = 0
        if length is None:
            length = os.path.getsize(source.name) * 8 - offset
        byteoffset, offset = divmod(offset, 8)
        bytelength = (length + byteoffset * 8 + offset + 7) // 8 - byteoffset
        m = MmapByteArray(source, bytelength, byteoffset)
        if length + byteoffset * 8 + offset > m.filelength * 8:
            raise CreationError('File is not long enough for specified length and offset.')
        self._datastore = ConstByteStore(m, length, offset)
        return

    def _setbytes_safe(self, data, length=None, offset=0):
        data = bytearray(data)
        if length is None:
            length = len(data) * 8 - offset
            self._datastore = ByteStore(data, length, offset)
        else:
            if length + offset > len(data) * 8:
                msg = 'Not enough data present. Need {0} bits, have {1}.'
                raise CreationError(msg, length + offset, len(data) * 8)
            if length == 0:
                self._datastore = ByteStore(bytearray(0))
            else:
                self._datastore = ByteStore(data, length, offset)
        return

    def _setbytes_unsafe(self, data, length, offset):
        self._datastore = ByteStore(data[:], length, offset)

    def _readbytes(self, length, start):
        return bytes(self._datastore.getbyteslice((start + self._offset) // 8, (start + self._offset + length) // 8)) if not (start + self._offset) % 8 else self._slice(start, start + length).tobytes()

    def _getbytes(self):
        if self.len % 8:
            raise InterpretError('Cannot interpret as bytes unambiguously - not multiple of 8 bits.')
        return self._readbytes(self.len, 0)

    def _setuint(self, uint, length=None):
        try:
            if length is None:
                length = self._datastore.bitlength
        except AttributeError:
            pass

        if length is None or length == 0:
            raise CreationError('A non-zero length must be specified with a uint initialiser.')
        if uint >= 1 << length:
            msg = '{0} is too large an unsigned integer for a bitstring of length {1}. The allowed range is [0, {2}].'
            raise CreationError(msg, uint, length, (1 << length) - 1)
        if uint < 0:
            raise CreationError('uint cannot be initialsed by a negative number.')
        s = hex(uint)[2:]
        s = s.rstrip('L')
        if len(s) & 1:
            s = '0' + s
        try:
            data = bytes.fromhex(s)
        except AttributeError:
            data = binascii.unhexlify(s)

        extrabytes = (length + 7) // 8 - len(data)
        if extrabytes > 0:
            data = '\x00' * extrabytes + data
        offset = 8 - length % 8
        if offset == 8:
            offset = 0
        self._setbytes_unsafe(bytearray(data), length, offset)
        return

    def _readuint(self, length, start):
        if not length:
            raise InterpretError('Cannot interpret a zero length bitstring as an integer.')
        offset = self._offset
        startbyte = (start + offset) // 8
        endbyte = (start + offset + length - 1) // 8
        b = binascii.hexlify(bytes(self._datastore.getbyteslice(startbyte, endbyte + 1)))
        i = int(b, 16)
        final_bits = 8 - (start + offset + length) % 8
        if final_bits != 8:
            i >>= final_bits
        i &= (1 << length) - 1
        return i

    def _getuint(self):
        return self._readuint(self.len, 0)

    def _setint(self, int_, length=None):
        if length is None and hasattr(self, 'len') and self.len != 0:
            length = self.len
        if length is None or length == 0:
            raise CreationError('A non-zero length must be specified with an int initialiser.')
        if int_ >= 1 << length - 1 or int_ < -(1 << length - 1):
            raise CreationError('{0} is too large a signed integer for a bitstring of length {1}. The allowed range is [{2}, {3}].', int_, length, -(1 << length - 1), (1 << length - 1) - 1)
        if int_ >= 0:
            self._setuint(int_, length)
            return
        else:
            int_ += 1
            self._setuint(-int_, length)
            self._invert_all()
            return

    def _readint(self, length, start):
        ui = self._readuint(length, start)
        if not ui >> length - 1:
            return ui
        tmp = ~(ui - 1) & (1 << length) - 1
        return -tmp

    def _getint(self):
        return self._readint(self.len, 0)

    def _setuintbe(self, uintbe, length=None):
        if length is not None and length % 8 != 0:
            raise CreationError('Big-endian integers must be whole-byte. Length = {0} bits.', length)
        self._setuint(uintbe, length)
        return

    def _readuintbe(self, length, start):
        if length % 8:
            raise InterpretError('Big-endian integers must be whole-byte. Length = {0} bits.', length)
        return self._readuint(length, start)

    def _getuintbe(self):
        return self._readuintbe(self.len, 0)

    def _setintbe(self, intbe, length=None):
        if length is not None and length % 8 != 0:
            raise CreationError('Big-endian integers must be whole-byte. Length = {0} bits.', length)
        self._setint(intbe, length)
        return

    def _readintbe(self, length, start):
        if length % 8:
            raise InterpretError('Big-endian integers must be whole-byte. Length = {0} bits.', length)
        return self._readint(length, start)

    def _getintbe(self):
        return self._readintbe(self.len, 0)

    def _setuintle(self, uintle, length=None):
        if length is not None and length % 8 != 0:
            raise CreationError('Little-endian integers must be whole-byte. Length = {0} bits.', length)
        self._setuint(uintle, length)
        self._reversebytes(0, self.len)
        return

    def _readuintle(self, length, start):
        if length % 8:
            raise InterpretError('Little-endian integers must be whole-byte. Length = {0} bits.', length)
        absolute_pos = start + self._offset
        startbyte, offset = divmod(absolute_pos, 8)
        val = 0
        if not offset:
            endbyte = (absolute_pos + length - 1) // 8
            chunksize = 4
            while endbyte - chunksize + 1 >= startbyte:
                val <<= 8 * chunksize
                val += struct.unpack('<L', bytes(self._datastore.getbyteslice(endbyte + 1 - chunksize, endbyte + 1)))[0]
                endbyte -= chunksize

            for b in xrange(endbyte, startbyte - 1, -1):
                val <<= 8
                val += self._datastore.getbyte(b)

        else:
            data = self._slice(start, start + length)
            data._reversebytes(0, self.len)
            for b in bytearray(data.bytes):
                val <<= 8
                val += b

        return val

    def _getuintle(self):
        return self._readuintle(self.len, 0)

    def _setintle(self, intle, length=None):
        if length is not None and length % 8 != 0:
            raise CreationError('Little-endian integers must be whole-byte. Length = {0} bits.', length)
        self._setint(intle, length)
        self._reversebytes(0, self.len)
        return

    def _readintle(self, length, start):
        ui = self._readuintle(length, start)
        if not ui >> length - 1:
            return ui
        tmp = ~(ui - 1) & (1 << length) - 1
        return -tmp

    def _getintle(self):
        return self._readintle(self.len, 0)

    def _setfloat(self, f, length=None):
        if length is None and hasattr(self, 'len') and self.len != 0:
            length = self.len
        if length is None or length == 0:
            raise CreationError('A non-zero length must be specified with a float initialiser.')
        if length == 32:
            b = struct.pack('>f', f)
        elif length == 64:
            b = struct.pack('>d', f)
        else:
            raise CreationError('floats can only be 32 or 64 bits long, not {0} bits', length)
        self._setbytes_unsafe(bytearray(b), length, 0)
        return

    def _readfloat(self, length, start):
        if not (start + self._offset) % 8:
            startbyte = (start + self._offset) // 8
            if length == 32:
                f = struct.unpack('>f', bytes(self._datastore.getbyteslice(startbyte, startbyte + 4)))
            elif length == 64:
                f = struct.unpack('>d', bytes(self._datastore.getbyteslice(startbyte, startbyte + 8)))
        elif length == 32:
            f = struct.unpack('>f', self._readbytes(32, start))
        elif length == 64:
            f = struct.unpack('>d', self._readbytes(64, start))
        try:
            return f
        except NameError:
            raise InterpretError('floats can only be 32 or 64 bits long, not {0} bits', length)

    def _getfloat(self):
        return self._readfloat(self.len, 0)

    def _setfloatle(self, f, length=None):
        if length is None and hasattr(self, 'len') and self.len != 0:
            length = self.len
        if length is None or length == 0:
            raise CreationError('A non-zero length must be specified with a float initialiser.')
        if length == 32:
            b = struct.pack('<f', f)
        elif length == 64:
            b = struct.pack('<d', f)
        else:
            raise CreationError('floats can only be 32 or 64 bits long, not {0} bits', length)
        self._setbytes_unsafe(bytearray(b), length, 0)
        return

    def _readfloatle(self, length, start):
        startbyte, offset = divmod(start + self._offset, 8)
        if not offset:
            if length == 32:
                f = struct.unpack('<f', bytes(self._datastore.getbyteslice(startbyte, startbyte + 4)))
            elif length == 64:
                f = struct.unpack('<d', bytes(self._datastore.getbyteslice(startbyte, startbyte + 8)))
        elif length == 32:
            f = struct.unpack('<f', self._readbytes(32, start))
        elif length == 64:
            f = struct.unpack('<d', self._readbytes(64, start))
        try:
            return f
        except NameError:
            raise InterpretError('floats can only be 32 or 64 bits long, not {0} bits', length)

    def _getfloatle(self):
        return self._readfloatle(self.len, 0)

    def _setue(self, i):
        if i < 0:
            raise CreationError('Cannot use negative initialiser for unsigned exponential-Golomb.')
        if not i:
            self._setbin_unsafe('1')
            return
        tmp = i + 1
        leadingzeros = -1
        while tmp > 0:
            tmp >>= 1
            leadingzeros += 1

        remainingpart = i + 1 - (1 << leadingzeros)
        binstring = '0' * leadingzeros + '1' + Bits(uint=remainingpart, length=leadingzeros).bin
        self._setbin_unsafe(binstring)

    def _readue(self, pos):
        oldpos = pos
        try:
            while not self[pos]:
                pos += 1

        except IndexError:
            raise ReadError('Read off end of bitstring trying to read code.')

        leadingzeros = pos - oldpos
        codenum = (1 << leadingzeros) - 1
        if leadingzeros > 0:
            if pos + leadingzeros + 1 > self.len:
                raise ReadError('Read off end of bitstring trying to read code.')
            codenum += self._readuint(leadingzeros, pos + 1)
            pos += leadingzeros + 1
        else:
            pos += 1
        return (codenum, pos)

    def _getue(self):
        try:
            value, newpos = self._readue(0)
            if value is None or newpos != self.len:
                raise ReadError
        except ReadError:
            raise InterpretError('Bitstring is not a single exponential-Golomb code.')

        return value

    def _setse(self, i):
        if i > 0:
            u = i * 2 - 1
        else:
            u = -2 * i
        self._setue(u)

    def _getse(self):
        try:
            value, newpos = self._readse(0)
            if value is None or newpos != self.len:
                raise ReadError
        except ReadError:
            raise InterpretError('Bitstring is not a single exponential-Golomb code.')

        return value

    def _readse(self, pos):
        codenum, pos = self._readue(pos)
        m = (codenum + 1) // 2
        if not codenum % 2:
            return (-m, pos)
        else:
            return (m, pos)

    def _setuie(self, i):
        if i < 0:
            raise CreationError('Cannot use negative initialiser for unsigned interleaved exponential-Golomb.')
        self._setbin_unsafe('1' if i == 0 else '0' + '0'.join(bin(i + 1)[3:]) + '1')

    def _readuie(self, pos):
        try:
            codenum = 1
            while not self[pos]:
                pos += 1
                codenum <<= 1
                codenum += self[pos]
                pos += 1

            pos += 1
        except IndexError:
            raise ReadError('Read off end of bitstring trying to read code.')

        codenum -= 1
        return (codenum, pos)

    def _getuie(self):
        try:
            value, newpos = self._readuie(0)
            if value is None or newpos != self.len:
                raise ReadError
        except ReadError:
            raise InterpretError('Bitstring is not a single interleaved exponential-Golomb code.')

        return value

    def _setsie(self, i):
        if not i:
            self._setbin_unsafe('1')
        else:
            self._setuie(abs(i))
            self._append(Bits([i < 0]))

    def _getsie(self):
        try:
            value, newpos = self._readsie(0)
            if value is None or newpos != self.len:
                raise ReadError
        except ReadError:
            raise InterpretError('Bitstring is not a single interleaved exponential-Golomb code.')

        return value

    def _readsie(self, pos):
        codenum, pos = self._readuie(pos)
        if not codenum:
            return (0, pos)
        try:
            if self[pos]:
                return (-codenum, pos + 1)
            return (codenum, pos + 1)
        except IndexError:
            raise ReadError('Read off end of bitstring trying to read code.')

    def _setbool(self, value):
        if value in (1, 'True'):
            self._setbytes_unsafe(bytearray('\x80'), 1, 0)
        elif value in (0, 'False'):
            self._setbytes_unsafe(bytearray('\x00'), 1, 0)
        else:
            raise CreationError('Cannot initialise boolean with {0}.', value)

    def _getbool(self):
        if self.length != 1:
            msg = 'For a bool interpretation a bitstring must be 1 bit long, not {0} bits.'
            raise InterpretError(msg, self.length)
        return self[0]

    def _readbool(self, pos):
        return (self[pos], pos + 1)

    def _setbin_safe(self, binstring):
        binstring = tidy_input_string(binstring)
        binstring = binstring.replace('0b', '')
        self._setbin_unsafe(binstring)

    def _setbin_unsafe(self, binstring):
        length = len(binstring)
        boundary = (length + 7) // 8 * 8
        padded_binstring = binstring + '0' * (boundary - length) if len(binstring) < boundary else binstring
        try:
            bytelist = [ int(padded_binstring[x:x + 8], 2) for x in xrange(0, len(padded_binstring), 8) ]
        except ValueError:
            raise CreationError('Invalid character in bin initialiser {0}.', binstring)

        self._setbytes_unsafe(bytearray(bytelist), length, 0)

    def _readbin(self, length, start):
        if not length:
            return ''
        startbyte, startoffset = divmod(start + self._offset, 8)
        endbyte = (start + self._offset + length - 1) // 8
        b = self._datastore.getbyteslice(startbyte, endbyte + 1)
        try:
            c = '{:0{}b}'.format(int(binascii.hexlify(b), 16), 8 * len(b))
        except TypeError:
            c = '{0:0{1}b}'.format(int(binascii.hexlify(str(b)), 16), 8 * len(b))

        return c[startoffset:startoffset + length]

    def _getbin(self):
        return self._readbin(self.len, 0)

    def _setoct(self, octstring):
        octstring = tidy_input_string(octstring)
        octstring = octstring.replace('0o', '')
        binlist = []
        for i in octstring:
            try:
                if not 0 <= int(i) < 8:
                    raise ValueError
                binlist.append(OCT_TO_BITS[int(i)])
            except ValueError:
                raise CreationError("Invalid symbol '{0}' in oct initialiser.", i)

        self._setbin_unsafe(''.join(binlist))

    def _readoct(self, length, start):
        if length % 3:
            raise InterpretError('Cannot convert to octal unambiguously - not multiple of 3 bits.')
        if not length:
            return ''
        end = oct(self._readuint(length, start))[LEADING_OCT_CHARS:]
        if end.endswith('L'):
            end = end[:-1]
        middle = '0' * (length // 3 - len(end))
        return middle + end

    def _getoct(self):
        return self._readoct(self.len, 0)

    def _sethex(self, hexstring):
        hexstring = tidy_input_string(hexstring)
        hexstring = hexstring.replace('0x', '')
        length = len(hexstring)
        if length % 2:
            hexstring += '0'
        try:
            try:
                data = bytearray.fromhex(hexstring)
            except TypeError:
                data = bytearray.fromhex(unicode(hexstring))

        except ValueError:
            raise CreationError('Invalid symbol in hex initialiser.')

        self._setbytes_unsafe(data, length * 4, 0)

    def _readhex(self, length, start):
        if length % 4:
            raise InterpretError('Cannot convert to hex unambiguously - not multiple of 4 bits.')
        if not length:
            return ''
        s = self._slice(start, start + length).tobytes()
        try:
            s = s.hex()
        except AttributeError:
            s = str(binascii.hexlify(s).decode('utf-8'))

        return s[:-1] if length // 4 % 2 else s

    def _gethex(self):
        return self._readhex(self.len, 0)

    def _getoffset(self):
        return self._datastore.offset

    def _getlength(self):
        return self._datastore.bitlength

    def _ensureinmemory(self):
        self._setbytes_unsafe(self._datastore.getbyteslice(0, self._datastore.bytelength), self.len, self._offset)

    @classmethod
    def _converttobitstring(cls, bs, offset=0, cache={}):
        if isinstance(bs, Bits):
            return bs
        try:
            return cache[bs, offset]
        except KeyError:
            if isinstance(bs, basestring):
                b = cls()
                try:
                    _, tokens = tokenparser(bs)
                except ValueError as e:
                    raise CreationError(*e.args)

                if tokens:
                    b._append(Bits._init_with_token(*tokens[0]))
                    b._datastore = offsetcopy(b._datastore, offset)
                    for token in tokens[1:]:
                        b._append(Bits._init_with_token(*token))

                if len(cache) < CACHE_SIZE:
                    cache[bs, offset] = b
                return b
        except TypeError:
            pass

        return cls(bs)

    def _copy(self):
        s_copy = self.__class__()
        s_copy._setbytes_unsafe(self._datastore.getbyteslice(0, self._datastore.bytelength), self.len, self._offset)
        return s_copy

    def _slice(self, start, end):
        if end == start:
            return self.__class__()
        offset = self._offset
        startbyte, newoffset = divmod(start + offset, 8)
        endbyte = (end + offset - 1) // 8
        bs = self.__class__()
        bs._setbytes_unsafe(self._datastore.getbyteslice(startbyte, endbyte + 1), end - start, newoffset)
        return bs

    def _readtoken(self, name, pos, length):
        if length is not None and int(length) > self.length - pos:
            raise ReadError('Reading off the end of the data. Tried to read {0} bits when only {1} available.'.format(int(length), self.length - pos))
        try:
            val = name_to_read[name](self, length, pos)
            return (val, pos + length)
        except KeyError:
            if name == 'pad':
                return (None, pos + length)
            raise ValueError("Can't parse token {0}:{1}".format(name, length))
        except TypeError:
            return name_to_read[name](self, pos)

        return

    def _append(self, bs):
        self._datastore._appendstore(bs._datastore)

    def _prepend(self, bs):
        self._datastore._prependstore(bs._datastore)

    def _reverse(self):
        n = [ BYTE_REVERSAL_DICT[b] for b in self._datastore.rawbytes ]
        n.reverse()
        newoffset = 8 - (self._offset + self.len) % 8
        if newoffset == 8:
            newoffset = 0
        self._setbytes_unsafe(bytearray().join(n), self.length, newoffset)

    def _truncatestart(self, bits):
        if not bits:
            return
        if bits == self.len:
            self._clear()
            return
        bytepos, offset = divmod(self._offset + bits, 8)
        self._setbytes_unsafe(self._datastore.getbyteslice(bytepos, self._datastore.bytelength), self.len - bits, offset)

    def _truncateend(self, bits):
        if not bits:
            return
        if bits == self.len:
            self._clear()
            return
        newlength_in_bytes = (self._offset + self.len - bits + 7) // 8
        self._setbytes_unsafe(self._datastore.getbyteslice(0, newlength_in_bytes), self.len - bits, self._offset)

    def _insert(self, bs, pos):
        if pos > self.len // 2:
            end = self._slice(pos, self.len)
            self._truncateend(self.len - pos)
            self._append(bs)
            self._append(end)
        else:
            start = self._slice(0, pos)
            self._truncatestart(pos)
            self._prepend(bs)
            self._prepend(start)
        try:
            self._pos = pos + bs.len
        except AttributeError:
            pass

    def _overwrite(self, bs, pos):
        if bs is self:
            return
        firstbytepos = (self._offset + pos) // 8
        lastbytepos = (self._offset + pos + bs.len - 1) // 8
        bytepos, bitoffset = divmod(self._offset + pos, 8)
        if firstbytepos == lastbytepos:
            mask = (1 << bs.len) - 1 << 8 - bs.len - bitoffset
            self._datastore.setbyte(bytepos, self._datastore.getbyte(bytepos) & ~mask)
            d = offsetcopy(bs._datastore, bitoffset)
            self._datastore.setbyte(bytepos, self._datastore.getbyte(bytepos) | d.getbyte(0) & mask)
        else:
            mask = (1 << 8 - bitoffset) - 1
            self._datastore.setbyte(bytepos, self._datastore.getbyte(bytepos) & ~mask)
            d = offsetcopy(bs._datastore, bitoffset)
            self._datastore.setbyte(bytepos, self._datastore.getbyte(bytepos) | d.getbyte(0) & mask)
            self._datastore.setbyteslice(firstbytepos + 1, lastbytepos, d.getbyteslice(1, lastbytepos - firstbytepos))
            bitsleft = (self._offset + pos + bs.len) % 8
            if not bitsleft:
                bitsleft = 8
            mask = (1 << 8 - bitsleft) - 1
            self._datastore.setbyte(lastbytepos, self._datastore.getbyte(lastbytepos) & mask)
            self._datastore.setbyte(lastbytepos, self._datastore.getbyte(lastbytepos) | d.getbyte(d.bytelength - 1) & ~mask)

    def _delete(self, bits, pos):
        if not pos:
            self._truncatestart(bits)
            return
        if pos + bits == self.len:
            self._truncateend(bits)
            return
        if pos > self.len - pos - bits:
            end = self._slice(pos + bits, self.len)
            self._truncateend(self.len - pos)
            self._append(end)
            return
        start = self._slice(0, pos)
        self._truncatestart(pos + bits)
        self._prepend(start)

    def _reversebytes(self, start, end):
        newoffset = 8 - start % 8
        if newoffset == 8:
            newoffset = 0
        self._datastore = offsetcopy(self._datastore, newoffset)
        toreverse = bytearray(self._datastore.getbyteslice((newoffset + start) // 8, (newoffset + end) // 8))
        toreverse.reverse()
        self._datastore.setbyteslice((newoffset + start) // 8, (newoffset + end) // 8, toreverse)

    def _set(self, pos):
        self._datastore.setbit(pos)

    def _unset(self, pos):
        self._datastore.unsetbit(pos)

    def _invert(self, pos):
        self._datastore.invertbit(pos)

    def _invert_all(self):
        set = self._datastore.setbyte
        get = self._datastore.getbyte
        for p in xrange(self._datastore.byteoffset, self._datastore.byteoffset + self._datastore.bytelength):
            set(p, 256 + ~get(p))

    def _ilshift(self, n):
        self._append(Bits(n))
        self._truncatestart(n)
        return self

    def _irshift(self, n):
        self._prepend(Bits(n))
        self._truncateend(n)
        return self

    def _imul(self, n):
        if not n:
            self._clear()
            return self
        m = 1
        old_len = self.len
        while m * 2 < n:
            self._append(self)
            m *= 2

        self._append(self[0:(n - m) * old_len])
        return self

    def _inplace_logical_helper(self, bs, f):
        self_byteoffset, self_bitoffset = divmod(self._offset, 8)
        bs_byteoffset, bs_bitoffset = divmod(bs._offset, 8)
        if bs_bitoffset != self_bitoffset:
            if not self_bitoffset:
                bs._datastore = offsetcopy(bs._datastore, 0)
            else:
                self._datastore = offsetcopy(self._datastore, bs_bitoffset)
        a = self._datastore.rawbytes
        b = bs._datastore.rawbytes
        for i in xrange(len(a)):
            a[i] = f(a[i + self_byteoffset], b[i + bs_byteoffset])

        return self

    def _ior(self, bs):
        return self._inplace_logical_helper(bs, operator.ior)

    def _iand(self, bs):
        return self._inplace_logical_helper(bs, operator.iand)

    def _ixor(self, bs):
        return self._inplace_logical_helper(bs, operator.xor)

    def _readbits(self, length, start):
        return self._slice(start, start + length)

    def _validate_slice(self, start, end):
        if start is None:
            start = 0
        elif start < 0:
            start += self.len
        if end is None:
            end = self.len
        elif end < 0:
            end += self.len
        if not 0 <= end <= self.len:
            raise ValueError('end is not a valid position in the bitstring.')
        if not 0 <= start <= self.len:
            raise ValueError('start is not a valid position in the bitstring.')
        if end < start:
            raise ValueError('end must not be less than start.')
        return (start, end)

    def unpack(self, fmt, **kwargs):
        return self._readlist(fmt, 0, **kwargs)[0]

    def _readlist(self, fmt, pos, **kwargs):
        tokens = []
        stretchy_token = None
        if isinstance(fmt, basestring):
            fmt = [fmt]
        for i, f in enumerate(fmt):
            if isinstance(f, numbers.Integral):
                fmt[i] = 'bits:{0}'.format(f)

        for f_item in fmt:
            stretchy, tkns = tokenparser(f_item, tuple(sorted(kwargs.keys())))
            if stretchy:
                if stretchy_token:
                    raise Error("It's not possible to have more than one 'filler' token.")
                stretchy_token = stretchy
            tokens.extend(tkns)

        if not stretchy_token:
            lst = []
            for name, length, _ in tokens:
                if length in kwargs:
                    length = kwargs[length]
                    if name == 'bytes':
                        length *= 8
                if name in kwargs and length is None:
                    value, pos = self._readtoken('uint', pos, kwargs[name])
                    lst.append(value)
                    continue
                value, pos = self._readtoken(name, pos, length)
                if value is not None:
                    lst.append(value)

            return (lst, pos)
        else:
            stretchy_token = False
            bits_after_stretchy_token = 0
            for token in tokens:
                name, length, _ = token
                if length in kwargs:
                    length = kwargs[length]
                    if name == 'bytes':
                        length *= 8
                if name in kwargs and length is None:
                    length = kwargs[name]
                if stretchy_token:
                    if name in ('se', 'ue', 'sie', 'uie'):
                        raise Error("It's not possible to parse a variablelength token after a 'filler' token.")
                    else:
                        if length is None:
                            raise Error("It's not possible to have more than one 'filler' token.")
                        bits_after_stretchy_token += length
                if length is None and name not in ('se', 'ue', 'sie', 'uie'):
                    stretchy_token = token

            bits_left = self.len - pos
            return_values = []
            for token in tokens:
                name, length, _ = token
                if token is stretchy_token:
                    length = max(bits_left - bits_after_stretchy_token, 0)
                if length in kwargs:
                    length = kwargs[length]
                    if name == 'bytes':
                        length *= 8
                if name in kwargs and length is None:
                    length = kwargs[name]
                if length is not None:
                    bits_left -= length
                value, pos = self._readtoken(name, pos, length)
                if value is not None:
                    return_values.append(value)

            return (return_values, pos)

    def _findbytes(self, bytes_, start, end, bytealigned):
        bytepos = (start + 7) // 8
        found = False
        p = bytepos
        finalpos = end // 8
        increment = max(1024, len(bytes_) * 10)
        buffersize = increment + len(bytes_)
        while p < finalpos:
            buf = bytearray(self._datastore.getbyteslice(p, min(p + buffersize, finalpos)))
            pos = buf.find(bytes_)
            if pos != -1:
                found = True
                p += pos
                break
            p += increment

        return () if not found else (p * 8,)

    def _findregex(self, reg_ex, start, end, bytealigned):
        p = start
        length = len(reg_ex.pattern)
        increment = max(4096, length * 10)
        buffersize = increment + length
        while p < end:
            buf = self._readbin(min(buffersize, end - p), p)
            m = reg_ex.search(buf)
            if m:
                pos = m.start()
                if not bytealigned or (p + pos) % 8 == 0:
                    return (p + pos,)
                if bytealigned:
                    p += pos + 1
                    continue
            p += increment

    def find(self, bs, start=None, end=None, bytealigned=None):
        bs = Bits(bs)
        if not bs.len:
            raise ValueError('Cannot find an empty bitstring.')
        start, end = self._validate_slice(start, end)
        if bytealigned is None:
            bytealigned = globals()['bytealigned']
        if bytealigned and not bs.len % 8 and not self._datastore.offset:
            p = self._findbytes(bs.bytes, start, end, bytealigned)
        else:
            p = self._findregex(re.compile(bs._getbin()), start, end, bytealigned)
        try:
            self._pos = p[0]
        except (AttributeError, IndexError):
            pass

        return p

    def findall(self, bs, start=None, end=None, count=None, bytealigned=None):
        if count is not None and count < 0:
            raise ValueError('In findall, count must be >= 0.')
        bs = Bits(bs)
        start, end = self._validate_slice(start, end)
        if bytealigned is None:
            bytealigned = globals()['bytealigned']
        c = 0
        if bytealigned and not bs.len % 8 and not self._datastore.offset:
            f = self._findbytes
            x = bs._getbytes()
        else:
            f = self._findregex
            x = re.compile(bs._getbin())
        while True:
            p = f(x, start, end, bytealigned)
            if not p:
                break
            if count is not None and c >= count:
                return
            c += 1
            try:
                self._pos = p[0]
            except AttributeError:
                pass

            yield p[0]
            if bytealigned:
                start = p[0] + 8
            else:
                start = p[0] + 1
            if start >= end:
                break

        return

    def rfind(self, bs, start=None, end=None, bytealigned=None):
        bs = Bits(bs)
        start, end = self._validate_slice(start, end)
        if bytealigned is None:
            bytealigned = globals()['bytealigned']
        if not bs.len:
            raise ValueError('Cannot find an empty bitstring.')
        increment = max(8192, bs.len * 80)
        buffersize = min(increment + bs.len, end - start)
        pos = max(start, end - buffersize)
        while True:
            found = list(self.findall(bs, start=pos, end=pos + buffersize, bytealigned=bytealigned))
            if not found:
                if pos == start:
                    return ()
                pos = max(start, pos - increment)
                continue
            return (found[-1],)

        return

    def cut(self, bits, start=None, end=None, count=None):
        start, end = self._validate_slice(start, end)
        if count is not None and count < 0:
            raise ValueError('Cannot cut - count must be >= 0.')
        if bits <= 0:
            raise ValueError('Cannot cut - bits must be >= 0.')
        c = 0
        while count is None or c < count:
            c += 1
            nextchunk = self._slice(start, min(start + bits, end))
            if nextchunk.len != bits:
                return
            yield nextchunk
            start += bits

        return

    def split(self, delimiter, start=None, end=None, count=None, bytealigned=None):
        delimiter = Bits(delimiter)
        if not delimiter.len:
            raise ValueError('split delimiter cannot be empty.')
        start, end = self._validate_slice(start, end)
        if bytealigned is None:
            bytealigned = globals()['bytealigned']
        if count is not None and count < 0:
            raise ValueError('Cannot split - count must be >= 0.')
        if count == 0:
            return
        else:
            if bytealigned and not delimiter.len % 8 and not self._datastore.offset:
                f = self._findbytes
                x = delimiter._getbytes()
            else:
                f = self._findregex
                x = re.compile(delimiter._getbin())
            found = f(x, start, end, bytealigned)
            if not found:
                yield self._slice(start, end)
                return
            yield self._slice(start, found[0])
            startpos = pos = found[0]
            c = 1
            while count is None or c < count:
                pos += delimiter.len
                found = f(x, pos, end, bytealigned)
                if not found:
                    yield self._slice(startpos, end)
                    return
                c += 1
                yield self._slice(startpos, found[0])
                startpos = pos = found[0]

            return

    def join(self, sequence):
        s = self.__class__()
        i = iter(sequence)
        try:
            s._append(Bits(next(i)))
            while True:
                n = next(i)
                s._append(self)
                s._append(Bits(n))

        except StopIteration:
            pass

        return s

    def tobytes(self):
        d = offsetcopy(self._datastore, 0).rawbytes
        unusedbits = 8 - self.len % 8
        if unusedbits != 8:
            d[-1] &= 255 << unusedbits
        return bytes(d)

    def tofile(self, f):
        chunksize = 1048576
        if not self._offset:
            a = 0
            bytelen = self._datastore.bytelength
            p = self._datastore.getbyteslice(a, min(a + chunksize, bytelen - 1))
            while len(p) == chunksize:
                f.write(p)
                a += chunksize
                p = self._datastore.getbyteslice(a, min(a + chunksize, bytelen - 1))

            f.write(p)
            bits_in_final_byte = self.len % 8
            if not bits_in_final_byte:
                bits_in_final_byte = 8
            f.write(self[-bits_in_final_byte:].tobytes())
        else:
            a = 0
            b = a + chunksize * 8
            while b <= self.len:
                f.write(self._slice(a, b)._getbytes())
                a += chunksize * 8
                b += chunksize * 8

            if a != self.len:
                f.write(self._slice(a, self.len).tobytes())

    def startswith(self, prefix, start=None, end=None):
        prefix = Bits(prefix)
        start, end = self._validate_slice(start, end)
        if end < start + prefix.len:
            return False
        end = start + prefix.len
        return self._slice(start, end) == prefix

    def endswith(self, suffix, start=None, end=None):
        suffix = Bits(suffix)
        start, end = self._validate_slice(start, end)
        if start + suffix.len > end:
            return False
        start = end - suffix.len
        return self._slice(start, end) == suffix

    def all(self, value, pos=None):
        value = bool(value)
        length = self.len
        if pos is None:
            pos = xrange(self.len)
        for p in pos:
            if p < 0:
                p += length
            if not 0 <= p < length:
                raise IndexError('Bit position {0} out of range.'.format(p))
            if self._datastore.getbit(p) is not value:
                return False

        return True

    def any(self, value, pos=None):
        value = bool(value)
        length = self.len
        if pos is None:
            pos = xrange(self.len)
        for p in pos:
            if p < 0:
                p += length
            if not 0 <= p < length:
                raise IndexError('Bit position {0} out of range.'.format(p))
            if self._datastore.getbit(p) is value:
                return True

        return False

    def count(self, value):
        if not self.len:
            return 0
        count = sum((BIT_COUNT[self._datastore.getbyte(i)] for i in xrange(self._datastore.bytelength - 1)))
        if self._offset:
            count -= BIT_COUNT[self._datastore.getbyte(0) >> 8 - self._offset]
        endbits = self._datastore.bytelength * 8 - (self._offset + self.len)
        count += BIT_COUNT[self._datastore.getbyte(self._datastore.bytelength - 1) >> endbits]
        return count if value else self.len - count

    if byteorder == 'little':
        _setfloatne = _setfloatle
        _readfloatne = _readfloatle
        _getfloatne = _getfloatle
        _setuintne = _setuintle
        _readuintne = _readuintle
        _getuintne = _getuintle
        _setintne = _setintle
        _readintne = _readintle
        _getintne = _getintle
    else:
        _setfloatne = _setfloat
        _readfloatne = _readfloat
        _getfloatne = _getfloat
        _setuintne = _setuintbe
        _readuintne = _readuintbe
        _getuintne = _getuintbe
        _setintne = _setintbe
        _readintne = _readintbe
        _getintne = _getintbe
    _offset = property(_getoffset)
    len = property(_getlength, doc='The length of the bitstring in bits. Read only.\n                      ')
    length = property(_getlength, doc='The length of the bitstring in bits. Read only.\n                      ')
    bool = property(_getbool, doc='The bitstring as a bool (True or False). Read only.\n                    ')
    hex = property(_gethex, doc='The bitstring as a hexadecimal string. Read only.\n                   ')
    bin = property(_getbin, doc='The bitstring as a binary string. Read only.\n                   ')
    oct = property(_getoct, doc='The bitstring as an octal string. Read only.\n                   ')
    bytes = property(_getbytes, doc='The bitstring as a bytes object. Read only.\n                      ')
    int = property(_getint, doc="The bitstring as a two's complement signed int. Read only.\n                      ")
    uint = property(_getuint, doc="The bitstring as a two's complement unsigned int. Read only.\n                      ")
    float = property(_getfloat, doc='The bitstring as a floating point number. Read only.\n                      ')
    intbe = property(_getintbe, doc="The bitstring as a two's complement big-endian signed int. Read only.\n                      ")
    uintbe = property(_getuintbe, doc="The bitstring as a two's complement big-endian unsigned int. Read only.\n                      ")
    floatbe = property(_getfloat, doc='The bitstring as a big-endian floating point number. Read only.\n                      ')
    intle = property(_getintle, doc="The bitstring as a two's complement little-endian signed int. Read only.\n                      ")
    uintle = property(_getuintle, doc="The bitstring as a two's complement little-endian unsigned int. Read only.\n                      ")
    floatle = property(_getfloatle, doc='The bitstring as a little-endian floating point number. Read only.\n                      ')
    intne = property(_getintne, doc="The bitstring as a two's complement native-endian signed int. Read only.\n                      ")
    uintne = property(_getuintne, doc="The bitstring as a two's complement native-endian unsigned int. Read only.\n                      ")
    floatne = property(_getfloatne, doc='The bitstring as a native-endian floating point number. Read only.\n                      ')
    ue = property(_getue, doc='The bitstring as an unsigned exponential-Golomb code. Read only.\n                      ')
    se = property(_getse, doc='The bitstring as a signed exponential-Golomb code. Read only.\n                      ')
    uie = property(_getuie, doc='The bitstring as an unsigned interleaved exponential-Golomb code. Read only.\n                      ')
    sie = property(_getsie, doc='The bitstring as a signed interleaved exponential-Golomb code. Read only.\n                      ')


name_to_read = {'uint': Bits._readuint,
 'uintle': Bits._readuintle,
 'uintbe': Bits._readuintbe,
 'uintne': Bits._readuintne,
 'int': Bits._readint,
 'intle': Bits._readintle,
 'intbe': Bits._readintbe,
 'intne': Bits._readintne,
 'float': Bits._readfloat,
 'floatbe': Bits._readfloat,
 'floatle': Bits._readfloatle,
 'floatne': Bits._readfloatne,
 'hex': Bits._readhex,
 'oct': Bits._readoct,
 'bin': Bits._readbin,
 'bits': Bits._readbits,
 'bytes': Bits._readbytes,
 'ue': Bits._readue,
 'se': Bits._readse,
 'uie': Bits._readuie,
 'sie': Bits._readsie,
 'bool': Bits._readbool}
init_with_length_and_offset = {'bytes': Bits._setbytes_safe,
 'filename': Bits._setfile}
init_with_length_only = {'uint': Bits._setuint,
 'int': Bits._setint,
 'float': Bits._setfloat,
 'uintbe': Bits._setuintbe,
 'intbe': Bits._setintbe,
 'floatbe': Bits._setfloat,
 'uintle': Bits._setuintle,
 'intle': Bits._setintle,
 'floatle': Bits._setfloatle,
 'uintne': Bits._setuintne,
 'intne': Bits._setintne,
 'floatne': Bits._setfloatne}
init_without_length_or_offset = {'bin': Bits._setbin_safe,
 'hex': Bits._sethex,
 'oct': Bits._setoct,
 'ue': Bits._setue,
 'se': Bits._setse,
 'uie': Bits._setuie,
 'sie': Bits._setsie,
 'bool': Bits._setbool}

class BitArray(Bits):
    __slots__ = ()
    __hash__ = None

    def __init__(self, auto=None, length=None, offset=None, **kwargs):
        if not isinstance(self._datastore, ByteStore):
            self._ensureinmemory()

    def __new__(cls, auto=None, length=None, offset=None, **kwargs):
        x = super(BitArray, cls).__new__(cls)
        y = Bits.__new__(BitArray, auto, length, offset, **kwargs)
        x._datastore = y._datastore
        return x

    def __iadd__(self, bs):
        self.append(bs)
        return self

    def __copy__(self):
        s_copy = BitArray()
        if not isinstance(self._datastore, ByteStore):
            s_copy._datastore = self._datastore
        else:
            s_copy._datastore = copy.copy(self._datastore)
        return s_copy

    def __setitem__(self, key, value):
        try:
            start, step = (0, 1)
            if key.step is not None:
                step = key.step
        except AttributeError:
            if key < 0:
                key += self.len
            if not 0 <= key < self.len:
                raise IndexError('Slice index out of range.')
            if isinstance(value, numbers.Integral):
                if not value:
                    self._unset(key)
                    return
                if value in (1, -1):
                    self._set(key)
                    return
                raise ValueError('Cannot set a single bit with integer {0}.'.format(value))
            value = Bits(value)
            if value.len == 1:
                if value[0]:
                    self._set(key)
                else:
                    self._unset(key)
            else:
                self._delete(1, key)
                self._insert(value, key)
            return

        if step != 1:
            temp = list(self._getbin())
            v = list(Bits(value)._getbin())
            temp.__setitem__(key, v)
            self._setbin_unsafe(''.join(temp))
            return
        else:
            if not isinstance(value, numbers.Integral):
                try:
                    value = Bits(value)
                except TypeError:
                    raise TypeError('Bitstring, integer or string expected. Got {0}.'.format(type(value)))

            if key.start is not None:
                start = key.start
                if key.start < 0:
                    start += self.len
                if start < 0:
                    start = 0
            stop = self.len
            if key.stop is not None:
                stop = key.stop
                if key.stop < 0:
                    stop += self.len
            if start > stop:
                stop = start
            if isinstance(value, numbers.Integral):
                if value >= 0:
                    value = self.__class__(uint=value, length=stop - start)
                else:
                    value = self.__class__(int=value, length=stop - start)
            stop = min(stop, self.len)
            start = max(start, 0)
            start = min(start, stop)
            if stop - start == value.len:
                if not value.len:
                    return
                if step >= 0:
                    self._overwrite(value, start)
                else:
                    self._overwrite(value.__getitem__(slice(None, None, 1)), start)
            else:
                self._delete(stop - start, start)
                if step >= 0:
                    self._insert(value, start)
                else:
                    self._insert(value.__getitem__(slice(None, None, 1)), start)
            return
            return

    def __delitem__(self, key):
        try:
            start = 0
            step = key.step if key.step is not None else 1
        except AttributeError:
            if key < 0:
                key += self.len
            if not 0 <= key < self.len:
                raise IndexError('Slice index out of range.')
            self._delete(1, key)
            return

        if step != 1:
            temp = list(self._getbin())
            temp.__delitem__(key)
            self._setbin_unsafe(''.join(temp))
            return
        else:
            stop = key.stop
            if key.start is not None:
                start = key.start
                if key.start < 0 and stop is None:
                    start += self.len
                if start < 0:
                    start = 0
            if stop is None:
                stop = self.len
            if start > stop:
                return
            stop = min(stop, self.len)
            start = max(start, 0)
            start = min(start, stop)
            self._delete(stop - start, start)
            return
            return

    def __ilshift__(self, n):
        if n < 0:
            raise ValueError('Cannot shift by a negative amount.')
        if not self.len:
            raise ValueError('Cannot shift an empty bitstring.')
        if not n:
            return self
        n = min(n, self.len)
        return self._ilshift(n)

    def __irshift__(self, n):
        if n < 0:
            raise ValueError('Cannot shift by a negative amount.')
        if not self.len:
            raise ValueError('Cannot shift an empty bitstring.')
        if not n:
            return self
        n = min(n, self.len)
        return self._irshift(n)

    def __imul__(self, n):
        if n < 0:
            raise ValueError('Cannot multiply by a negative integer.')
        return self._imul(n)

    def __ior__(self, bs):
        bs = Bits(bs)
        if self.len != bs.len:
            raise ValueError('Bitstrings must have the same length for |= operator.')
        return self._ior(bs)

    def __iand__(self, bs):
        bs = Bits(bs)
        if self.len != bs.len:
            raise ValueError('Bitstrings must have the same length for &= operator.')
        return self._iand(bs)

    def __ixor__(self, bs):
        bs = Bits(bs)
        if self.len != bs.len:
            raise ValueError('Bitstrings must have the same length for ^= operator.')
        return self._ixor(bs)

    def replace(self, old, new, start=None, end=None, count=None, bytealigned=None):
        old = Bits(old)
        new = Bits(new)
        if not old.len:
            raise ValueError('Empty bitstring cannot be replaced.')
        start, end = self._validate_slice(start, end)
        if bytealigned is None:
            bytealigned = globals()['bytealigned']
        if count is not None:
            count += 1
        sections = self.split(old, start, end, count, bytealigned)
        lengths = [ s.len for s in sections ]
        if len(lengths) == 1:
            return 0
        else:
            if new is self:
                new = copy.copy(self)
            positions = [lengths[0] + start]
            for l in lengths[1:-1]:
                positions.append(positions[-1] + l)

            positions.reverse()
            try:
                newpos = self._pos
                for p in positions:
                    self[p:p + old.len] = new

                if old.len != new.len:
                    diff = new.len - old.len
                    for p in positions:
                        if p >= newpos:
                            continue
                        if p + old.len <= newpos:
                            newpos += diff
                        newpos = p

                self._pos = newpos
            except AttributeError:
                for p in positions:
                    self[p:p + old.len] = new

            return len(lengths) - 1

    def insert(self, bs, pos=None):
        bs = Bits(bs)
        if not bs.len:
            return self
        else:
            if bs is self:
                bs = self.__copy__()
            if pos is None:
                try:
                    pos = self._pos
                except AttributeError:
                    raise TypeError('insert require a bit position for this type.')

            if pos < 0:
                pos += self.len
            if not 0 <= pos <= self.len:
                raise ValueError('Invalid insert position.')
            self._insert(bs, pos)
            return

    def overwrite(self, bs, pos=None):
        bs = Bits(bs)
        if not bs.len:
            return
        else:
            if pos is None:
                try:
                    pos = self._pos
                except AttributeError:
                    raise TypeError('overwrite require a bit position for this type.')

            if pos < 0:
                pos += self.len
            if pos < 0 or pos + bs.len > self.len:
                raise ValueError('Overwrite exceeds boundary of bitstring.')
            self._overwrite(bs, pos)
            try:
                self._pos = pos + bs.len
            except AttributeError:
                pass

            return

    def append(self, bs):
        bs = self._converttobitstring(bs, offset=(self.len + self._offset) % 8)
        self._append(bs)

    def prepend(self, bs):
        bs = Bits(bs)
        self._prepend(bs)

    def reverse(self, start=None, end=None):
        start, end = self._validate_slice(start, end)
        if start == 0 and end == self.len:
            self._reverse()
            return
        s = self._slice(start, end)
        s._reverse()
        self[start:end] = s

    def set(self, value, pos=None):
        f = self._set if value else self._unset
        if pos is None:
            pos = xrange(self.len)
        try:
            length = self.len
            for p in pos:
                if p < 0:
                    p += length
                if not 0 <= p < length:
                    raise IndexError('Bit position {0} out of range.'.format(p))
                f(p)

        except TypeError:
            if pos < 0:
                pos += self.len
            if not 0 <= pos < length:
                raise IndexError('Bit position {0} out of range.'.format(pos))
            f(pos)

        return

    def invert(self, pos=None):
        if pos is None:
            self._invert_all()
            return
        else:
            if not isinstance(pos, collections.Iterable):
                pos = (pos,)
            length = self.len
            for p in pos:
                if p < 0:
                    p += length
                if not 0 <= p < length:
                    raise IndexError('Bit position {0} out of range.'.format(p))
                self._invert(p)

            return

    def ror(self, bits, start=None, end=None):
        if not self.len:
            raise Error('Cannot rotate an empty bitstring.')
        if bits < 0:
            raise ValueError('Cannot rotate right by negative amount.')
        start, end = self._validate_slice(start, end)
        bits %= end - start
        if not bits:
            return
        rhs = self._slice(end - bits, end)
        self._delete(bits, end - bits)
        self._insert(rhs, start)

    def rol(self, bits, start=None, end=None):
        if not self.len:
            raise Error('Cannot rotate an empty bitstring.')
        if bits < 0:
            raise ValueError('Cannot rotate left by negative amount.')
        start, end = self._validate_slice(start, end)
        bits %= end - start
        if not bits:
            return
        lhs = self._slice(start, start + bits)
        self._delete(bits, start)
        self._insert(lhs, end - bits)

    def byteswap(self, fmt=None, start=None, end=None, repeat=True):
        start, end = self._validate_slice(start, end)
        if fmt is None or fmt == 0:
            bytesizes = [(end - start) // 8]
        elif isinstance(fmt, numbers.Integral):
            if fmt < 0:
                raise ValueError('Improper byte length {0}.'.format(fmt))
            bytesizes = [fmt]
        elif isinstance(fmt, basestring):
            m = STRUCT_PACK_RE.match(fmt)
            if not m:
                raise ValueError('Cannot parse format string {0}.'.format(fmt))
            formatlist = re.findall(STRUCT_SPLIT_RE, m.group('fmt'))
            bytesizes = []
            for f in formatlist:
                if len(f) == 1:
                    bytesizes.append(PACK_CODE_SIZE[f])
                bytesizes.extend([PACK_CODE_SIZE[f[-1]]] * int(f[:-1]))

        elif isinstance(fmt, collections.Iterable):
            bytesizes = fmt
            for bytesize in bytesizes:
                if not isinstance(bytesize, numbers.Integral) or bytesize < 0:
                    raise ValueError('Improper byte length {0}.'.format(bytesize))

        else:
            raise TypeError('Format must be an integer, string or iterable.')
        repeats = 0
        totalbitsize = 8 * sum(bytesizes)
        if not totalbitsize:
            return 0
        else:
            if repeat:
                finalbit = end
            else:
                finalbit = start + totalbitsize
            for patternend in xrange(start + totalbitsize, finalbit + 1, totalbitsize):
                bytestart = patternend - totalbitsize
                for bytesize in bytesizes:
                    byteend = bytestart + bytesize * 8
                    self._reversebytes(bytestart, byteend)
                    bytestart += bytesize * 8

                repeats += 1

            return repeats

    def clear(self):
        self._clear()

    def copy(self):
        return self._copy()

    int = property(Bits._getint, Bits._setint, doc="The bitstring as a two's complement signed int. Read and write.\n                      ")
    uint = property(Bits._getuint, Bits._setuint, doc="The bitstring as a two's complement unsigned int. Read and write.\n                      ")
    float = property(Bits._getfloat, Bits._setfloat, doc='The bitstring as a floating point number. Read and write.\n                      ')
    intbe = property(Bits._getintbe, Bits._setintbe, doc="The bitstring as a two's complement big-endian signed int. Read and write.\n                      ")
    uintbe = property(Bits._getuintbe, Bits._setuintbe, doc="The bitstring as a two's complement big-endian unsigned int. Read and write.\n                      ")
    floatbe = property(Bits._getfloat, Bits._setfloat, doc='The bitstring as a big-endian floating point number. Read and write.\n                      ')
    intle = property(Bits._getintle, Bits._setintle, doc="The bitstring as a two's complement little-endian signed int. Read and write.\n                      ")
    uintle = property(Bits._getuintle, Bits._setuintle, doc="The bitstring as a two's complement little-endian unsigned int. Read and write.\n                      ")
    floatle = property(Bits._getfloatle, Bits._setfloatle, doc='The bitstring as a little-endian floating point number. Read and write.\n                      ')
    intne = property(Bits._getintne, Bits._setintne, doc="The bitstring as a two's complement native-endian signed int. Read and write.\n                      ")
    uintne = property(Bits._getuintne, Bits._setuintne, doc="The bitstring as a two's complement native-endian unsigned int. Read and write.\n                      ")
    floatne = property(Bits._getfloatne, Bits._setfloatne, doc='The bitstring as a native-endian floating point number. Read and write.\n                      ')
    ue = property(Bits._getue, Bits._setue, doc='The bitstring as an unsigned exponential-Golomb code. Read and write.\n                      ')
    se = property(Bits._getse, Bits._setse, doc='The bitstring as a signed exponential-Golomb code. Read and write.\n                      ')
    uie = property(Bits._getuie, Bits._setuie, doc='The bitstring as an unsigned interleaved exponential-Golomb code. Read and write.\n                      ')
    sie = property(Bits._getsie, Bits._setsie, doc='The bitstring as a signed interleaved exponential-Golomb code. Read and write.\n                      ')
    hex = property(Bits._gethex, Bits._sethex, doc='The bitstring as a hexadecimal string. Read and write.\n                       ')
    bin = property(Bits._getbin, Bits._setbin_safe, doc='The bitstring as a binary string. Read and write.\n                       ')
    oct = property(Bits._getoct, Bits._setoct, doc='The bitstring as an octal string. Read and write.\n                       ')
    bool = property(Bits._getbool, Bits._setbool, doc='The bitstring as a bool (True or False). Read and write.\n                    ')
    bytes = property(Bits._getbytes, Bits._setbytes_safe, doc='The bitstring as a ordinary string. Read and write.\n                      ')


class ConstBitStream(Bits):
    __slots__ = '_pos'

    def __init__(self, auto=None, length=None, offset=None, **kwargs):
        self._pos = 0

    def __new__(cls, auto=None, length=None, offset=None, **kwargs):
        x = super(ConstBitStream, cls).__new__(cls)
        x._initialise(auto, length, offset, **kwargs)
        return x

    def _setbytepos(self, bytepos):
        self._setbitpos(bytepos * 8)

    def _getbytepos(self):
        if self._pos % 8:
            raise ByteAlignError('Not byte aligned in _getbytepos().')
        return self._pos // 8

    def _setbitpos(self, pos):
        if pos < 0:
            raise ValueError('Bit position cannot be negative.')
        if pos > self.len:
            raise ValueError('Cannot seek past the end of the data.')
        self._pos = pos

    def _getbitpos(self):
        return self._pos

    def _clear(self):
        Bits._clear(self)
        self._pos = 0

    def __copy__(self):
        s = ConstBitStream()
        s._datastore = self._datastore
        s._pos = 0
        return s

    def __add__(self, bs):
        s = Bits.__add__(self, bs)
        s._pos = 0
        return s

    def read(self, fmt):
        if isinstance(fmt, numbers.Integral):
            if fmt < 0:
                raise ValueError('Cannot read negative amount.')
            if fmt > self.len - self._pos:
                raise ReadError('Cannot read {0} bits, only {1} available.', fmt, self.len - self._pos)
            bs = self._slice(self._pos, self._pos + fmt)
            self._pos += fmt
            return bs
        else:
            p = self._pos
            _, token = tokenparser(fmt)
            if len(token) != 1:
                self._pos = p
                raise ValueError('Format string should be a single token, not {0} tokens - use readlist() instead.'.format(len(token)))
            name, length, _ = token[0]
            if length is None:
                length = self.len - self._pos
            value, self._pos = self._readtoken(name, self._pos, length)
            return value

    def readlist(self, fmt, **kwargs):
        value, self._pos = self._readlist(fmt, self._pos, **kwargs)
        return value

    def readto(self, bs, bytealigned=None):
        if isinstance(bs, numbers.Integral):
            raise ValueError('Integers cannot be searched for')
        bs = Bits(bs)
        oldpos = self._pos
        p = self.find(bs, self._pos, bytealigned=bytealigned)
        if not p:
            raise ReadError('Substring not found')
        self._pos += bs.len
        return self._slice(oldpos, self._pos)

    def peek(self, fmt):
        pos_before = self._pos
        value = self.read(fmt)
        self._pos = pos_before
        return value

    def peeklist(self, fmt, **kwargs):
        pos = self._pos
        return_values = self.readlist(fmt, **kwargs)
        self._pos = pos
        return return_values

    def bytealign(self):
        skipped = (8 - self._pos % 8) % 8
        self.pos += self._offset + skipped
        return skipped

    pos = property(_getbitpos, _setbitpos, doc='The position in the bitstring in bits. Read and write.\n                      ')
    bitpos = property(_getbitpos, _setbitpos, doc='The position in the bitstring in bits. Read and write.\n                      ')
    bytepos = property(_getbytepos, _setbytepos, doc='The position in the bitstring in bytes. Read and write.\n                      ')


class BitStream(ConstBitStream, BitArray):
    __slots__ = ()
    __hash__ = None

    def __init__(self, auto=None, length=None, offset=None, **kwargs):
        self._pos = 0
        if not isinstance(self._datastore, ByteStore):
            self._ensureinmemory()

    def __new__(cls, auto=None, length=None, offset=None, **kwargs):
        x = super(BitStream, cls).__new__(cls)
        x._initialise(auto, length, offset, **kwargs)
        return x

    def __copy__(self):
        s_copy = BitStream()
        s_copy._pos = 0
        if not isinstance(self._datastore, ByteStore):
            s_copy._datastore = self._datastore
        else:
            s_copy._datastore = ByteStore(self._datastore._rawarray[:], self._datastore.bitlength, self._datastore.offset)
        return s_copy

    def prepend(self, bs):
        bs = self._converttobitstring(bs)
        self._prepend(bs)
        self._pos += bs.len


def pack(fmt, *values, **kwargs):
    tokens = []
    if isinstance(fmt, basestring):
        fmt = [fmt]
    try:
        for f_item in fmt:
            _, tkns = tokenparser(f_item, tuple(sorted(kwargs.keys())))
            tokens.extend(tkns)

    except ValueError as e:
        raise CreationError(*e.args)

    value_iter = iter(values)
    s = BitStream()
    try:
        for name, length, value in tokens:
            if value in kwargs:
                value = kwargs[value]
            if length in kwargs:
                length = kwargs[length]
            if name in kwargs and length is None and value is None:
                s.append(kwargs[name])
                continue
            if length is not None:
                length = int(length)
            if value is None and name != 'pad':
                value = next(value_iter)
            s._append(BitStream._init_with_token(name, length, value))

    except StopIteration:
        raise CreationError('Not enough parameters present to pack according to the format. {0} values are needed.', len(tokens))

    try:
        next(value_iter)
    except StopIteration:
        return s

    raise CreationError('Too many parameters present to pack according to the format.')
    return


ConstBitArray = Bits
BitString = BitStream
__all__ = ['ConstBitArray',
 'ConstBitStream',
 'BitStream',
 'BitArray',
 'Bits',
 'BitString',
 'pack',
 'Error',
 'ReadError',
 'InterpretError',
 'ByteAlignError',
 'CreationError',
 'bytealigned']
