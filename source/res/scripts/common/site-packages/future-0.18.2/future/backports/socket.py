# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-0.18.2/future/backports/socket.py
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future.builtins import super
import _socket
from _socket import *
import os, sys, io
try:
    import errno
except ImportError:
    errno = None

EBADF = getattr(errno, u'EBADF', 9)
EAGAIN = getattr(errno, u'EAGAIN', 11)
EWOULDBLOCK = getattr(errno, u'EWOULDBLOCK', 11)
__all__ = [u'getfqdn', u'create_connection']
__all__.extend(os._get_exports_list(_socket))
_realsocket = socket
if sys.platform.lower().startswith(u'win'):
    errorTab = {}
    errorTab[10004] = u'The operation was interrupted.'
    errorTab[10009] = u'A bad file handle was passed.'
    errorTab[10013] = u'Permission denied.'
    errorTab[10014] = u'A fault occurred on the network??'
    errorTab[10022] = u'An invalid operation was attempted.'
    errorTab[10035] = u'The socket operation would block'
    errorTab[10036] = u'A blocking operation is already in progress.'
    errorTab[10048] = u'The network address is in use.'
    errorTab[10054] = u'The connection has been reset.'
    errorTab[10058] = u'The network has been shut down.'
    errorTab[10060] = u'The operation timed out.'
    errorTab[10061] = u'Connection refused.'
    errorTab[10063] = u'The name is too long.'
    errorTab[10064] = u'The host is down.'
    errorTab[10065] = u'The host is unreachable.'
    __all__.append(u'errorTab')

class socket(_socket.socket):
    __slots__ = [u'__weakref__', u'_io_refs', u'_closed']

    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):
        if fileno is None:
            _socket.socket.__init__(self, family, type, proto)
        else:
            _socket.socket.__init__(self, family, type, proto, fileno)
        self._io_refs = 0
        self._closed = False
        return

    def __enter__(self):
        return self

    def __exit__(self, *args):
        if not self._closed:
            self.close()

    def __repr__(self):
        s = _socket.socket.__repr__(self)
        if s.startswith(u'<socket object'):
            s = u'<%s.%s%s%s' % (self.__class__.__module__,
             self.__class__.__name__,
             getattr(self, u'_closed', False) and u' [closed] ' or u'',
             s[7:])
        return s

    def __getstate__(self):
        raise TypeError(u'Cannot serialize socket object')

    def dup(self):
        fd = dup(self.fileno())
        sock = self.__class__(self.family, self.type, self.proto, fileno=fd)
        sock.settimeout(self.gettimeout())
        return sock

    def accept(self):
        fd, addr = self._accept()
        sock = socket(self.family, self.type, self.proto, fileno=fd)
        if getdefaulttimeout() is None and self.gettimeout():
            sock.setblocking(True)
        return (sock, addr)

    def makefile(self, mode=u'r', buffering=None, **_3to2kwargs):
        if u'newline' in _3to2kwargs:
            newline = _3to2kwargs[u'newline']
            del _3to2kwargs[u'newline']
        else:
            newline = None
        if u'errors' in _3to2kwargs:
            errors = _3to2kwargs[u'errors']
            del _3to2kwargs[u'errors']
        else:
            errors = None
        if u'encoding' in _3to2kwargs:
            encoding = _3to2kwargs[u'encoding']
            del _3to2kwargs[u'encoding']
        else:
            encoding = None
        for c in mode:
            if c not in (u'r', u'w', u'b'):
                raise ValueError(u'invalid mode %r (only r, w, b allowed)')

        writing = u'w' in mode
        reading = u'r' in mode or not writing
        binary = u'b' in mode
        rawmode = u''
        if reading:
            rawmode += u'r'
        if writing:
            rawmode += u'w'
        raw = SocketIO(self, rawmode)
        self._io_refs += 1
        if buffering is None:
            buffering = -1
        if buffering < 0:
            buffering = io.DEFAULT_BUFFER_SIZE
        if buffering == 0:
            if not binary:
                raise ValueError(u'unbuffered streams must be binary')
            return raw
        else:
            if reading and writing:
                buffer = io.BufferedRWPair(raw, raw, buffering)
            elif reading:
                buffer = io.BufferedReader(raw, buffering)
            else:
                buffer = io.BufferedWriter(raw, buffering)
            if binary:
                return buffer
            text = io.TextIOWrapper(buffer, encoding, errors, newline)
            text.mode = mode
            return text

    def _decref_socketios(self):
        if self._io_refs > 0:
            self._io_refs -= 1
        if self._closed:
            self.close()

    def _real_close(self, _ss=_socket.socket):
        _ss.close(self)

    def close(self):
        self._closed = True
        if self._io_refs <= 0:
            self._real_close()

    def detach(self):
        self._closed = True
        return super().detach()


def fromfd(fd, family, type, proto=0):
    nfd = dup(fd)
    return socket(family, type, proto, nfd)


if hasattr(_socket.socket, u'share'):

    def fromshare(info):
        return socket(0, 0, 0, info)


if hasattr(_socket, u'socketpair'):

    def socketpair(family=None, type=SOCK_STREAM, proto=0):
        if family is None:
            try:
                family = AF_UNIX
            except NameError:
                family = AF_INET

        a, b = _socket.socketpair(family, type, proto)
        a = socket(family, type, proto, a.detach())
        b = socket(family, type, proto, b.detach())
        return (a, b)


_blocking_errnos = set([EAGAIN, EWOULDBLOCK])

class SocketIO(io.RawIOBase):

    def __init__(self, sock, mode):
        if mode not in (u'r', u'w', u'rw', u'rb', u'wb', u'rwb'):
            raise ValueError(u'invalid mode: %r' % mode)
        io.RawIOBase.__init__(self)
        self._sock = sock
        if u'b' not in mode:
            mode += u'b'
        self._mode = mode
        self._reading = u'r' in mode
        self._writing = u'w' in mode
        self._timeout_occurred = False

    def readinto(self, b):
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise IOError(u'cannot read from timed out object')
        while True:
            try:
                return self._sock.recv_into(b)
            except timeout:
                self._timeout_occurred = True
                raise
            except error as e:
                if e.args[0] in _blocking_errnos:
                    return None
                raise

        return None

    def write(self, b):
        self._checkClosed()
        self._checkWritable()
        try:
            return self._sock.send(b)
        except error as e:
            if e.args[0] in _blocking_errnos:
                return None
            raise

        return None

    def readable(self):
        if self.closed:
            raise ValueError(u'I/O operation on closed socket.')
        return self._reading

    def writable(self):
        if self.closed:
            raise ValueError(u'I/O operation on closed socket.')
        return self._writing

    def seekable(self):
        if self.closed:
            raise ValueError(u'I/O operation on closed socket.')
        return super().seekable()

    def fileno(self):
        self._checkClosed()
        return self._sock.fileno()

    @property
    def name(self):
        if not self.closed:
            return self.fileno()
        else:
            return -1

    @property
    def mode(self):
        return self._mode

    def close(self):
        if self.closed:
            return
        else:
            io.RawIOBase.close(self)
            self._sock._decref_socketios()
            self._sock = None
            return


def getfqdn(name=u''):
    name = name.strip()
    if not name or name == u'0.0.0.0':
        name = gethostname()
    try:
        hostname, aliases, ipaddrs = gethostbyaddr(name)
    except error:
        pass
    else:
        aliases.insert(0, hostname)
        for name in aliases:
            if u'.' in name:
                break
        else:
            name = hostname

    return name


from socket import _GLOBAL_DEFAULT_TIMEOUT

def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None):
    host, port = address
    err = None
    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        sock = None
        try:
            sock = socket(af, socktype, proto)
            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                sock.settimeout(timeout)
            if source_address:
                sock.bind(source_address)
            sock.connect(sa)
            return sock
        except error as _:
            err = _
            if sock is not None:
                sock.close()

    if err is not None:
        raise err
    else:
        raise error(u'getaddrinfo returns an empty list')
    return
