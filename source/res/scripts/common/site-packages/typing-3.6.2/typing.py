# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/typing-3.6.2/typing.py
from __future__ import absolute_import, unicode_literals
import abc
from abc import abstractmethod, abstractproperty
import collections
import functools
import re as stdlib_re
import sys
import types
try:
    import collections.abc as collections_abc
except ImportError:
    import collections as collections_abc

__all__ = [u'Any',
 u'Callable',
 u'ClassVar',
 u'Generic',
 u'Optional',
 u'Tuple',
 u'Type',
 u'TypeVar',
 u'Union',
 u'AbstractSet',
 u'GenericMeta',
 u'ByteString',
 u'Container',
 u'ContextManager',
 u'Hashable',
 u'ItemsView',
 u'Iterable',
 u'Iterator',
 u'KeysView',
 u'Mapping',
 u'MappingView',
 u'MutableMapping',
 u'MutableSequence',
 u'MutableSet',
 u'Sequence',
 u'Sized',
 u'ValuesView',
 u'Reversible',
 u'SupportsAbs',
 u'SupportsComplex',
 u'SupportsFloat',
 u'SupportsInt',
 u'Counter',
 u'Deque',
 u'Dict',
 u'DefaultDict',
 u'List',
 u'Set',
 u'FrozenSet',
 u'NamedTuple',
 u'Generator',
 u'AnyStr',
 u'cast',
 u'get_type_hints',
 u'NewType',
 u'no_type_check',
 u'no_type_check_decorator',
 u'overload',
 u'Text',
 u'TYPE_CHECKING']

def _qualname(x):
    if sys.version_info[:2] >= (3, 3):
        return x.__qualname__
    else:
        return x.__name__


def _trim_name(nm):
    whitelist = (u'_TypeAlias', u'_ForwardRef', u'_TypingBase', u'_FinalTypingBase')
    if nm.startswith(u'_') and nm not in whitelist:
        nm = nm[1:]
    return nm


class TypingMeta(type):
    _is_protocol = False

    def __new__(cls, name, bases, namespace):
        return super(TypingMeta, cls).__new__(cls, str(name), bases, namespace)

    @classmethod
    def assert_no_subclassing(cls, bases):
        for base in bases:
            if isinstance(base, cls):
                raise TypeError(u'Cannot subclass %s' % (u', '.join(map(_type_repr, bases)) or u'()'))

    def __init__(self, *args, **kwds):
        pass

    def _eval_type(self, globalns, localns):
        return self

    def _get_type_vars(self, tvars):
        pass

    def __repr__(self):
        qname = _trim_name(_qualname(self))
        return u'%s.%s' % (self.__module__, qname)


class _TypingBase(object):
    __metaclass__ = TypingMeta
    __slots__ = (u'__weakref__',)

    def __init__(self, *args, **kwds):
        pass

    def __new__(cls, *args, **kwds):
        if len(args) == 3 and isinstance(args[0], str) and isinstance(args[1], tuple):
            raise TypeError(u'Cannot subclass %r' % cls)
        return super(_TypingBase, cls).__new__(cls)

    def _eval_type(self, globalns, localns):
        return self

    def _get_type_vars(self, tvars):
        pass

    def __repr__(self):
        cls = type(self)
        qname = _trim_name(_qualname(cls))
        return u'%s.%s' % (cls.__module__, qname)

    def __call__(self, *args, **kwds):
        raise TypeError(u'Cannot instantiate %r' % type(self))


class _FinalTypingBase(_TypingBase):
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        self = super(_FinalTypingBase, cls).__new__(cls, *args, **kwds)
        if u'_root' in kwds and kwds[u'_root'] is True:
            return self
        raise TypeError(u'Cannot instantiate %r' % cls)

    def __reduce__(self):
        return _trim_name(type(self).__name__)


class _ForwardRef(_TypingBase):
    __slots__ = (u'__forward_arg__', u'__forward_code__', u'__forward_evaluated__', u'__forward_value__')

    def __init__(self, arg):
        super(_ForwardRef, self).__init__(arg)
        if not isinstance(arg, basestring):
            raise TypeError(u'Forward reference must be a string -- got %r' % (arg,))
        try:
            code = compile(arg, u'<string>', u'eval')
        except SyntaxError:
            raise SyntaxError(u'Forward reference must be an expression -- got %r' % (arg,))

        self.__forward_arg__ = arg
        self.__forward_code__ = code
        self.__forward_evaluated__ = False
        self.__forward_value__ = None
        return

    def _eval_type(self, globalns, localns):
        if not self.__forward_evaluated__ or localns is not globalns:
            if globalns is None and localns is None:
                globalns = localns = {}
            elif globalns is None:
                globalns = localns
            elif localns is None:
                localns = globalns
            self.__forward_value__ = _type_check(eval(self.__forward_code__, globalns, localns), u'Forward references must evaluate to types.')
            self.__forward_evaluated__ = True
        return self.__forward_value__

    def __eq__(self, other):
        return NotImplemented if not isinstance(other, _ForwardRef) else self.__forward_arg__ == other.__forward_arg__ and self.__forward_value__ == other.__forward_value__

    def __hash__(self):
        return hash((self.__forward_arg__, self.__forward_value__))

    def __instancecheck__(self, obj):
        raise TypeError(u'Forward references cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(u'Forward references cannot be used with issubclass().')

    def __repr__(self):
        return u'_ForwardRef(%r)' % (self.__forward_arg__,)


class _TypeAlias(_TypingBase):
    __slots__ = (u'name', u'type_var', u'impl_type', u'type_checker')

    def __init__(self, name, type_var, impl_type, type_checker):
        self.name = name
        self.type_var = type_var
        self.impl_type = impl_type
        self.type_checker = type_checker

    def __repr__(self):
        return u'%s[%s]' % (self.name, _type_repr(self.type_var))

    def __getitem__(self, parameter):
        if not isinstance(self.type_var, TypeVar):
            raise TypeError(u'%s cannot be further parameterized.' % self)
        if self.type_var.__constraints__ and isinstance(parameter, type):
            if not issubclass(parameter, self.type_var.__constraints__):
                raise TypeError(u'%s is not a valid substitution for %s.' % (parameter, self.type_var))
        if isinstance(parameter, TypeVar) and parameter is not self.type_var:
            raise TypeError(u'%s cannot be re-parameterized.' % self)
        return self.__class__(self.name, parameter, self.impl_type, self.type_checker)

    def __eq__(self, other):
        return NotImplemented if not isinstance(other, _TypeAlias) else self.name == other.name and self.type_var == other.type_var

    def __hash__(self):
        return hash((self.name, self.type_var))

    def __instancecheck__(self, obj):
        if not isinstance(self.type_var, TypeVar):
            raise TypeError(u'Parameterized type aliases cannot be used with isinstance().')
        return isinstance(obj, self.impl_type)

    def __subclasscheck__(self, cls):
        if not isinstance(self.type_var, TypeVar):
            raise TypeError(u'Parameterized type aliases cannot be used with issubclass().')
        return issubclass(cls, self.impl_type)


def _get_type_vars(types, tvars):
    for t in types:
        if isinstance(t, TypingMeta) or isinstance(t, _TypingBase):
            t._get_type_vars(tvars)


def _type_vars(types):
    tvars = []
    _get_type_vars(types, tvars)
    return tuple(tvars)


def _eval_type(t, globalns, localns):
    return t._eval_type(globalns, localns) if isinstance(t, TypingMeta) or isinstance(t, _TypingBase) else t


def _type_check(arg, msg):
    if arg is None:
        return type(None)
    else:
        if isinstance(arg, basestring):
            arg = _ForwardRef(arg)
        if isinstance(arg, _TypingBase) and type(arg).__name__ == u'_ClassVar' or not isinstance(arg, (type, _TypingBase)) and not callable(arg):
            raise TypeError(msg + u' Got %.100r.' % (arg,))
        if type(arg).__name__ in (u'_Union', u'_Optional') and not getattr(arg, u'__origin__', None) or isinstance(arg, TypingMeta) and _gorg(arg) in (Generic, _Protocol):
            raise TypeError(u'Plain %s is not valid as type argument' % arg)
        return arg


def _type_repr(obj):
    if isinstance(obj, type) and not isinstance(obj, TypingMeta):
        if obj.__module__ == u'__builtin__':
            return _qualname(obj)
        return u'%s.%s' % (obj.__module__, _qualname(obj))
    if obj is Ellipsis:
        return u'...'
    return obj.__name__ if isinstance(obj, types.FunctionType) else repr(obj)


class ClassVarMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        self = super(ClassVarMeta, cls).__new__(cls, name, bases, namespace)
        return self


class _ClassVar(_FinalTypingBase):
    __metaclass__ = ClassVarMeta
    __slots__ = (u'__type__',)

    def __init__(self, tp=None, _root=False):
        self.__type__ = tp

    def __getitem__(self, item):
        cls = type(self)
        if self.__type__ is None:
            return cls(_type_check(item, u'{} accepts only types.'.format(cls.__name__[1:])), _root=True)
        else:
            raise TypeError(u'{} cannot be further subscripted'.format(cls.__name__[1:]))
            return

    def _eval_type(self, globalns, localns):
        return type(self)(_eval_type(self.__type__, globalns, localns), _root=True)

    def __repr__(self):
        r = super(_ClassVar, self).__repr__()
        if self.__type__ is not None:
            r += u'[{}]'.format(_type_repr(self.__type__))
        return r

    def __hash__(self):
        return hash((type(self).__name__, self.__type__))

    def __eq__(self, other):
        if not isinstance(other, _ClassVar):
            return NotImplemented
        else:
            return self.__type__ == other.__type__ if self.__type__ is not None else self is other


ClassVar = _ClassVar(_root=True)

class AnyMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        self = super(AnyMeta, cls).__new__(cls, name, bases, namespace)
        return self


class _Any(_FinalTypingBase):
    __metaclass__ = AnyMeta
    __slots__ = ()

    def __instancecheck__(self, obj):
        raise TypeError(u'Any cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(u'Any cannot be used with issubclass().')


Any = _Any(_root=True)

class NoReturnMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        self = super(NoReturnMeta, cls).__new__(cls, name, bases, namespace)
        return self


class _NoReturn(_FinalTypingBase):
    __metaclass__ = NoReturnMeta
    __slots__ = ()

    def __instancecheck__(self, obj):
        raise TypeError(u'NoReturn cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(u'NoReturn cannot be used with issubclass().')


NoReturn = _NoReturn(_root=True)

class TypeVarMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        return super(TypeVarMeta, cls).__new__(cls, name, bases, namespace)


class TypeVar(_TypingBase):
    __metaclass__ = TypeVarMeta
    __slots__ = (u'__name__', u'__bound__', u'__constraints__', u'__covariant__', u'__contravariant__')

    def __init__(self, name, *constraints, **kwargs):
        super(TypeVar, self).__init__(name, *constraints, **kwargs)
        bound = kwargs.get(u'bound', None)
        covariant = kwargs.get(u'covariant', False)
        contravariant = kwargs.get(u'contravariant', False)
        self.__name__ = name
        if covariant and contravariant:
            raise ValueError(u'Bivariant types are not supported.')
        self.__covariant__ = bool(covariant)
        self.__contravariant__ = bool(contravariant)
        if constraints and bound is not None:
            raise TypeError(u'Constraints cannot be combined with bound=...')
        if constraints and len(constraints) == 1:
            raise TypeError(u'A single constraint is not allowed')
        msg = u'TypeVar(name, constraint, ...): constraints must be types.'
        self.__constraints__ = tuple((_type_check(t, msg) for t in constraints))
        if bound:
            self.__bound__ = _type_check(bound, u'Bound must be a type.')
        else:
            self.__bound__ = None
        return

    def _get_type_vars(self, tvars):
        if self not in tvars:
            tvars.append(self)

    def __repr__(self):
        if self.__covariant__:
            prefix = u'+'
        elif self.__contravariant__:
            prefix = u'-'
        else:
            prefix = u'~'
        return prefix + self.__name__

    def __instancecheck__(self, instance):
        raise TypeError(u'Type variables cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(u'Type variables cannot be used with issubclass().')


T = TypeVar(u'T')
KT = TypeVar(u'KT')
VT = TypeVar(u'VT')
T_co = TypeVar(u'T_co', covariant=True)
V_co = TypeVar(u'V_co', covariant=True)
VT_co = TypeVar(u'VT_co', covariant=True)
T_contra = TypeVar(u'T_contra', contravariant=True)
AnyStr = TypeVar(u'AnyStr', bytes, unicode)

def _replace_arg(arg, tvars, args):
    if tvars is None:
        tvars = []
    if hasattr(arg, u'_subs_tree') and isinstance(arg, (GenericMeta, _TypingBase)):
        return arg._subs_tree(tvars, args)
    else:
        if isinstance(arg, TypeVar):
            for i, tvar in enumerate(tvars):
                if arg == tvar:
                    return args[i]

        return arg


def _subs_tree(cls, tvars=None, args=None):
    if cls.__origin__ is None:
        return cls
    else:
        current = cls.__origin__
        orig_chain = []
        while current.__origin__ is not None:
            orig_chain.append(current)
            current = current.__origin__

        tree_args = []
        for arg in cls.__args__:
            tree_args.append(_replace_arg(arg, tvars, args))

        for ocls in orig_chain:
            new_tree_args = []
            for arg in ocls.__args__:
                new_tree_args.append(_replace_arg(arg, ocls.__parameters__, tree_args))

            tree_args = new_tree_args

        return tree_args


def _remove_dups_flatten(parameters):
    params = []
    for p in parameters:
        if isinstance(p, _Union) and p.__origin__ is Union:
            params.extend(p.__args__)
        if isinstance(p, tuple) and len(p) > 0 and p[0] is Union:
            params.extend(p[1:])
        params.append(p)

    all_params = set(params)
    if len(all_params) < len(params):
        new_params = []
        for t in params:
            if t in all_params:
                new_params.append(t)
                all_params.remove(t)

        params = new_params
    all_params = set(params)
    for t1 in params:
        if not isinstance(t1, type):
            continue
        if any((isinstance(t2, type) and issubclass(t1, t2) for t2 in all_params - {t1} if not (isinstance(t2, GenericMeta) and t2.__origin__ is not None))):
            all_params.remove(t1)

    return tuple((t for t in params if t in all_params))


def _check_generic(cls, parameters):
    if not cls.__parameters__:
        raise TypeError(u'%s is not a generic class' % repr(cls))
    alen = len(parameters)
    elen = len(cls.__parameters__)
    if alen != elen:
        raise TypeError(u'Too %s parameters for %s; actual %s, expected %s' % (u'many' if alen > elen else u'few',
         repr(cls),
         alen,
         elen))


_cleanups = []

def _tp_cache(func):
    maxsize = 128
    cache = {}
    _cleanups.append(cache.clear)

    @functools.wraps(func)
    def inner(*args):
        key = args
        try:
            return cache[key]
        except TypeError:
            return func(*args)
        except KeyError:
            value = func(*args)
            if len(cache) >= maxsize:
                cache.clear()
            cache[key] = value
            return value

    return inner


class UnionMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        return super(UnionMeta, cls).__new__(cls, name, bases, namespace)


class _Union(_FinalTypingBase):
    __metaclass__ = UnionMeta
    __slots__ = (u'__parameters__', u'__args__', u'__origin__', u'__tree_hash__')

    def __new__(cls, parameters=None, origin=None, *args, **kwds):
        self = super(_Union, cls).__new__(cls, parameters, origin, *args, **kwds)
        if origin is None:
            self.__parameters__ = None
            self.__args__ = None
            self.__origin__ = None
            self.__tree_hash__ = hash(frozenset((u'Union',)))
            return self
        else:
            if not isinstance(parameters, tuple):
                raise TypeError(u'Expected parameters=<tuple>')
            if origin is Union:
                parameters = _remove_dups_flatten(parameters)
                if len(parameters) == 1:
                    return parameters[0]
            self.__parameters__ = _type_vars(parameters)
            self.__args__ = parameters
            self.__origin__ = origin
            subs_tree = self._subs_tree()
            if isinstance(subs_tree, tuple):
                self.__tree_hash__ = hash(frozenset(subs_tree))
            else:
                self.__tree_hash__ = hash(subs_tree)
            return self

    def _eval_type(self, globalns, localns):
        if self.__args__ is None:
            return self
        else:
            ev_args = tuple((_eval_type(t, globalns, localns) for t in self.__args__))
            ev_origin = _eval_type(self.__origin__, globalns, localns)
            return self if ev_args == self.__args__ and ev_origin == self.__origin__ else self.__class__(ev_args, ev_origin, _root=True)

    def _get_type_vars(self, tvars):
        if self.__origin__ and self.__parameters__:
            _get_type_vars(self.__parameters__, tvars)

    def __repr__(self):
        if self.__origin__ is None:
            return super(_Union, self).__repr__()
        else:
            tree = self._subs_tree()
            return repr(tree) if not isinstance(tree, tuple) else tree[0]._tree_repr(tree)

    def _tree_repr(self, tree):
        arg_list = []
        for arg in tree[1:]:
            if not isinstance(arg, tuple):
                arg_list.append(_type_repr(arg))
            arg_list.append(arg[0]._tree_repr(arg))

        return super(_Union, self).__repr__() + u'[%s]' % u', '.join(arg_list)

    @_tp_cache
    def __getitem__(self, parameters):
        if parameters == ():
            raise TypeError(u'Cannot take a Union of no types.')
        if not isinstance(parameters, tuple):
            parameters = (parameters,)
        if self.__origin__ is None:
            msg = u'Union[arg, ...]: each arg must be a type.'
        else:
            msg = u'Parameters to generic types must be types.'
        parameters = tuple((_type_check(p, msg) for p in parameters))
        if self is not Union:
            _check_generic(self, parameters)
        return self.__class__(parameters, origin=self, _root=True)

    def _subs_tree(self, tvars=None, args=None):
        if self is Union:
            return Union
        tree_args = _subs_tree(self, tvars, args)
        tree_args = _remove_dups_flatten(tree_args)
        return tree_args[0] if len(tree_args) == 1 else (Union,) + tree_args

    def __eq__(self, other):
        if isinstance(other, _Union):
            return self.__tree_hash__ == other.__tree_hash__
        elif self is not Union:
            return self._subs_tree() == other
        else:
            return self is other

    def __hash__(self):
        return self.__tree_hash__

    def __instancecheck__(self, obj):
        raise TypeError(u'Unions cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        raise TypeError(u'Unions cannot be used with issubclass().')


Union = _Union(_root=True)

class OptionalMeta(TypingMeta):

    def __new__(cls, name, bases, namespace):
        cls.assert_no_subclassing(bases)
        return super(OptionalMeta, cls).__new__(cls, name, bases, namespace)


class _Optional(_FinalTypingBase):
    __metaclass__ = OptionalMeta
    __slots__ = ()

    @_tp_cache
    def __getitem__(self, arg):
        arg = _type_check(arg, u'Optional[t] requires a single type.')
        return Union[arg, type(None)]


Optional = _Optional(_root=True)

def _gorg(a):
    while a.__origin__ is not None:
        a = a.__origin__

    return a


def _geqv(a, b):
    return _gorg(a) is _gorg(b)


def _next_in_mro(cls):
    next_in_mro = object
    for i, c in enumerate(cls.__mro__[:-1]):
        if isinstance(c, GenericMeta) and _gorg(c) is Generic:
            next_in_mro = cls.__mro__[i + 1]

    return next_in_mro


def _make_subclasshook(cls):
    if isinstance(cls.__extra__, abc.ABCMeta):

        def __extrahook__(cls, subclass):
            res = cls.__extra__.__subclasshook__(subclass)
            if res is not NotImplemented:
                return res
            if cls.__extra__ in getattr(subclass, u'__mro__', ()):
                return True
            for scls in cls.__extra__.__subclasses__():
                if isinstance(scls, GenericMeta):
                    continue
                if issubclass(subclass, scls):
                    return True

            return NotImplemented

    else:

        def __extrahook__(cls, subclass):
            return True if cls.__extra__ and issubclass(subclass, cls.__extra__) else NotImplemented

    return classmethod(__extrahook__)


class GenericMeta(TypingMeta, abc.ABCMeta):

    def __new__(cls, name, bases, namespace, tvars=None, args=None, origin=None, extra=None, orig_bases=None):
        if tvars is not None:
            pass
        else:
            tvars = _type_vars(bases)
            gvars = None
            for base in bases:
                if base is Generic:
                    raise TypeError(u'Cannot inherit from plain Generic')
                if isinstance(base, GenericMeta) and base.__origin__ is Generic:
                    if gvars is not None:
                        raise TypeError(u'Cannot inherit from Generic[...] multiple types.')
                    gvars = base.__parameters__

            if gvars is None:
                gvars = tvars
            else:
                tvarset = set(tvars)
                gvarset = set(gvars)
                if not tvarset <= gvarset:
                    raise TypeError(u'Some type variables (%s) are not listed in Generic[%s]' % (u', '.join((str(t) for t in tvars if t not in gvarset)), u', '.join((str(g) for g in gvars))))
                tvars = gvars
        initial_bases = bases
        if extra is None:
            extra = namespace.get(u'__extra__')
        if extra is not None and type(extra) is abc.ABCMeta and extra not in bases:
            bases = (extra,) + bases
        bases = tuple(((_gorg(b) if isinstance(b, GenericMeta) else b) for b in bases))
        if any((isinstance(b, GenericMeta) and b is not Generic for b in bases)):
            bases = tuple((b for b in bases if b is not Generic))
        namespace.update({u'__origin__': origin,
         u'__extra__': extra})
        self = super(GenericMeta, cls).__new__(cls, name, bases, namespace)
        self.__parameters__ = tvars
        self.__args__ = tuple(((Ellipsis if a is _TypingEllipsis else (() if a is _TypingEmpty else a)) for a in args)) if args else None
        self.__next_in_mro__ = _next_in_mro(self)
        if orig_bases is None:
            self.__orig_bases__ = initial_bases
        if u'__subclasshook__' not in namespace and extra or getattr(self.__subclasshook__, u'__name__', u'') == u'__extrahook__':
            self.__subclasshook__ = _make_subclasshook(self)
        if origin and hasattr(origin, u'__qualname__'):
            self.__qualname__ = origin.__qualname__
        self.__tree_hash__ = hash(self._subs_tree()) if origin else super(GenericMeta, self).__hash__()
        return self

    def __init__(self, *args, **kwargs):
        super(GenericMeta, self).__init__(*args, **kwargs)
        if isinstance(self.__extra__, abc.ABCMeta):
            self._abc_registry = self.__extra__._abc_registry
            self._abc_cache = self.__extra__._abc_cache
        elif self.__origin__ is not None:
            self._abc_registry = self.__origin__._abc_registry
            self._abc_cache = self.__origin__._abc_cache
        return

    @property
    def _abc_negative_cache(self):
        return self.__extra__._abc_negative_cache if isinstance(self.__extra__, abc.ABCMeta) else _gorg(self)._abc_generic_negative_cache

    @_abc_negative_cache.setter
    def _abc_negative_cache(self, value):
        if self.__origin__ is None:
            if isinstance(self.__extra__, abc.ABCMeta):
                self.__extra__._abc_negative_cache = value
            else:
                self._abc_generic_negative_cache = value
        return

    @property
    def _abc_negative_cache_version(self):
        return self.__extra__._abc_negative_cache_version if isinstance(self.__extra__, abc.ABCMeta) else _gorg(self)._abc_generic_negative_cache_version

    @_abc_negative_cache_version.setter
    def _abc_negative_cache_version(self, value):
        if self.__origin__ is None:
            if isinstance(self.__extra__, abc.ABCMeta):
                self.__extra__._abc_negative_cache_version = value
            else:
                self._abc_generic_negative_cache_version = value
        return

    def _get_type_vars(self, tvars):
        if self.__origin__ and self.__parameters__:
            _get_type_vars(self.__parameters__, tvars)

    def _eval_type(self, globalns, localns):
        ev_origin = self.__origin__._eval_type(globalns, localns) if self.__origin__ else None
        ev_args = tuple((_eval_type(a, globalns, localns) for a in self.__args__)) if self.__args__ else None
        return self if ev_origin == self.__origin__ and ev_args == self.__args__ else self.__class__(self.__name__, self.__bases__, dict(self.__dict__), tvars=_type_vars(ev_args) if ev_args else None, args=ev_args, origin=ev_origin, extra=self.__extra__, orig_bases=self.__orig_bases__)

    def __repr__(self):
        return super(GenericMeta, self).__repr__() if self.__origin__ is None else self._tree_repr(self._subs_tree())

    def _tree_repr(self, tree):
        arg_list = []
        for arg in tree[1:]:
            if arg == ():
                arg_list.append(u'()')
            if not isinstance(arg, tuple):
                arg_list.append(_type_repr(arg))
            arg_list.append(arg[0]._tree_repr(arg))

        return super(GenericMeta, self).__repr__() + u'[%s]' % u', '.join(arg_list)

    def _subs_tree(self, tvars=None, args=None):
        if self.__origin__ is None:
            return self
        else:
            tree_args = _subs_tree(self, tvars, args)
            return (_gorg(self),) + tuple(tree_args)

    def __eq__(self, other):
        if not isinstance(other, GenericMeta):
            return NotImplemented
        else:
            return self is other if self.__origin__ is None or other.__origin__ is None else self.__tree_hash__ == other.__tree_hash__

    def __hash__(self):
        return self.__tree_hash__

    @_tp_cache
    def __getitem__(self, params):
        if not isinstance(params, tuple):
            params = (params,)
        if not params and _gorg(self) is not Tuple:
            raise TypeError(u'Parameter list to %s[...] cannot be empty' % _qualname(self))
        msg = u'Parameters to generic types must be types.'
        params = tuple((_type_check(p, msg) for p in params))
        if self is Generic:
            if not all((isinstance(p, TypeVar) for p in params)):
                raise TypeError(u'Parameters to Generic[...] must all be type variables')
            if len(set(params)) != len(params):
                raise TypeError(u'Parameters to Generic[...] must all be unique')
            tvars = params
            args = params
        elif self in (Tuple, Callable):
            tvars = _type_vars(params)
            args = params
        elif self is _Protocol:
            tvars = params
            args = params
        elif self.__origin__ in (Generic, _Protocol):
            raise TypeError(u'Cannot subscript already-subscripted %s' % repr(self))
        else:
            _check_generic(self, params)
            tvars = _type_vars(params)
            args = params
        prepend = (self,) if self.__origin__ is None else ()
        return self.__class__(self.__name__, prepend + self.__bases__, dict(self.__dict__), tvars=tvars, args=args, origin=self, extra=self.__extra__, orig_bases=self.__orig_bases__)

    def __subclasscheck__(self, cls):
        if self.__origin__ is not None:
            if sys._getframe(1).f_globals[u'__name__'] not in (u'abc', u'functools'):
                raise TypeError(u'Parameterized generics cannot be used with class or instance checks')
            return False
        else:
            if self is Generic:
                raise TypeError(u'Class %r cannot be used with class or instance checks' % self)
            return super(GenericMeta, self).__subclasscheck__(cls)

    def __instancecheck__(self, instance):
        return issubclass(instance.__class__, self) if not isinstance(instance, type) else False

    def __copy__(self):
        return self.__class__(self.__name__, self.__bases__, dict(self.__dict__), self.__parameters__, self.__args__, self.__origin__, self.__extra__, self.__orig_bases__)

    def __setattr__(self, attr, value):
        if attr.startswith(u'__') and attr.endswith(u'__') or attr.startswith(u'_abc_'):
            super(GenericMeta, self).__setattr__(attr, value)
        else:
            super(GenericMeta, _gorg(self)).__setattr__(attr, value)


Generic = None

def _generic_new(base_cls, cls, *args, **kwds):
    if cls.__origin__ is None:
        return base_cls.__new__(cls)
    else:
        origin = _gorg(cls)
        obj = base_cls.__new__(origin)
        try:
            obj.__orig_class__ = cls
        except AttributeError:
            pass

        obj.__init__(*args, **kwds)
        return obj
        return


class Generic(object):
    __metaclass__ = GenericMeta
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Generic):
            raise TypeError(u'Type Generic cannot be instantiated; it can be used only as a base class')
        return _generic_new(cls.__next_in_mro__, cls, *args, **kwds)


class _TypingEmpty(object):
    pass


class _TypingEllipsis(object):
    pass


class TupleMeta(GenericMeta):

    @_tp_cache
    def __getitem__(self, parameters):
        if self.__origin__ is not None or not _geqv(self, Tuple):
            return super(TupleMeta, self).__getitem__(parameters)
        elif parameters == ():
            return super(TupleMeta, self).__getitem__((_TypingEmpty,))
        else:
            if not isinstance(parameters, tuple):
                parameters = (parameters,)
            if len(parameters) == 2 and parameters[1] is Ellipsis:
                msg = u'Tuple[t, ...]: t must be a type.'
                p = _type_check(parameters[0], msg)
                return super(TupleMeta, self).__getitem__((p, _TypingEllipsis))
            msg = u'Tuple[t0, t1, ...]: each t must be a type.'
            parameters = tuple((_type_check(p, msg) for p in parameters))
            return super(TupleMeta, self).__getitem__(parameters)

    def __instancecheck__(self, obj):
        if self.__args__ is None:
            return isinstance(obj, tuple)
        else:
            raise TypeError(u'Parameterized Tuple cannot be used with isinstance().')
            return

    def __subclasscheck__(self, cls):
        if self.__args__ is None:
            return issubclass(cls, tuple)
        else:
            raise TypeError(u'Parameterized Tuple cannot be used with issubclass().')
            return


class Tuple(tuple):
    __metaclass__ = TupleMeta
    __extra__ = tuple
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Tuple):
            raise TypeError(u'Type Tuple cannot be instantiated; use tuple() instead')
        return _generic_new(tuple, cls, *args, **kwds)


class CallableMeta(GenericMeta):

    def __repr__(self):
        return super(CallableMeta, self).__repr__() if self.__origin__ is None else self._tree_repr(self._subs_tree())

    def _tree_repr(self, tree):
        if _gorg(self) is not Callable:
            return super(CallableMeta, self)._tree_repr(tree)
        arg_list = []
        for arg in tree[1:]:
            if not isinstance(arg, tuple):
                arg_list.append(_type_repr(arg))
            arg_list.append(arg[0]._tree_repr(arg))

        return repr(tree[0]) + u'[..., %s]' % arg_list[1] if arg_list[0] == u'...' else repr(tree[0]) + u'[[%s], %s]' % (u', '.join(arg_list[:-1]), arg_list[-1])

    def __getitem__(self, parameters):
        if self.__origin__ is not None or not _geqv(self, Callable):
            return super(CallableMeta, self).__getitem__(parameters)
        else:
            if not isinstance(parameters, tuple) or len(parameters) != 2:
                raise TypeError(u'Callable must be used as Callable[[arg, ...], result].')
            args, result = parameters
            if args is Ellipsis:
                parameters = (Ellipsis, result)
            else:
                if not isinstance(args, list):
                    raise TypeError(u'Callable[args, result]: args must be a list. Got %.100r.' % (args,))
                parameters = (tuple(args), result)
            return self.__getitem_inner__(parameters)

    @_tp_cache
    def __getitem_inner__(self, parameters):
        args, result = parameters
        msg = u'Callable[args, result]: result must be a type.'
        result = _type_check(result, msg)
        if args is Ellipsis:
            return super(CallableMeta, self).__getitem__((_TypingEllipsis, result))
        msg = u'Callable[[arg, ...], result]: each arg must be a type.'
        args = tuple((_type_check(arg, msg) for arg in args))
        parameters = args + (result,)
        return super(CallableMeta, self).__getitem__(parameters)


class Callable(object):
    __metaclass__ = CallableMeta
    __extra__ = collections_abc.Callable
    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Callable):
            raise TypeError(u'Type Callable cannot be instantiated; use a non-abstract subclass instead')
        return _generic_new(cls.__next_in_mro__, cls, *args, **kwds)


def cast(typ, val):
    return val


def _get_defaults(func):
    code = func.__code__
    pos_count = code.co_argcount
    arg_names = code.co_varnames
    arg_names = arg_names[:pos_count]
    defaults = func.__defaults__ or ()
    kwdefaults = func.__kwdefaults__
    res = dict(kwdefaults) if kwdefaults else {}
    pos_offset = pos_count - len(defaults)
    for name, value in zip(arg_names[pos_offset:], defaults):
        res[name] = value

    return res


def get_type_hints(obj, globalns=None, localns=None):
    return None


def no_type_check(arg):
    if isinstance(arg, type):
        arg_attrs = arg.__dict__.copy()
        for attr, val in arg.__dict__.items():
            if val in arg.__bases__:
                arg_attrs.pop(attr)

        for obj in arg_attrs.values():
            if isinstance(obj, types.FunctionType):
                obj.__no_type_check__ = True
            if isinstance(obj, type):
                no_type_check(obj)

    try:
        arg.__no_type_check__ = True
    except TypeError:
        pass

    return arg


def no_type_check_decorator(decorator):

    @functools.wraps(decorator)
    def wrapped_decorator(*args, **kwds):
        func = decorator(*args, **kwds)
        func = no_type_check(func)
        return func

    return wrapped_decorator


def _overload_dummy(*args, **kwds):
    raise NotImplementedError(u'You should not call an overloaded function. A series of @overload-decorated functions outside a stub module should always be followed by an implementation that is not @overload-ed.')


def overload(func):
    return _overload_dummy


class _ProtocolMeta(GenericMeta):

    def __instancecheck__(self, obj):
        if _Protocol not in self.__bases__:
            return super(_ProtocolMeta, self).__instancecheck__(obj)
        raise TypeError(u'Protocols cannot be used with isinstance().')

    def __subclasscheck__(self, cls):
        if not self._is_protocol:
            return NotImplemented
        if self is _Protocol:
            return True
        attrs = self._get_protocol_attrs()
        for attr in attrs:
            if not any((attr in d.__dict__ for d in cls.__mro__)):
                return False

        return True

    def _get_protocol_attrs(self):
        protocol_bases = []
        for c in self.__mro__:
            if getattr(c, u'_is_protocol', False) and c.__name__ != u'_Protocol':
                protocol_bases.append(c)

        attrs = set()
        for base in protocol_bases:
            for attr in base.__dict__.keys():
                for c in self.__mro__:
                    if c is not base and attr in c.__dict__ and not getattr(c, u'_is_protocol', False):
                        break
                else:
                    if not attr.startswith(u'_abc_') and attr != u'__abstractmethods__' and attr != u'_is_protocol' and attr != u'__dict__' and attr != u'__args__' and attr != u'__slots__' and attr != u'_get_protocol_attrs' and attr != u'__next_in_mro__' and attr != u'__parameters__' and attr != u'__origin__' and attr != u'__orig_bases__' and attr != u'__extra__' and attr != u'__tree_hash__' and attr != u'__module__':
                        attrs.add(attr)

        return attrs


class _Protocol(object):
    __metaclass__ = _ProtocolMeta
    __slots__ = ()
    _is_protocol = True


Hashable = collections_abc.Hashable

class Iterable(Generic[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Iterable


class Iterator(Iterable[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Iterator


class SupportsInt(_Protocol):
    __slots__ = ()

    @abstractmethod
    def __int__(self):
        pass


class SupportsFloat(_Protocol):
    __slots__ = ()

    @abstractmethod
    def __float__(self):
        pass


class SupportsComplex(_Protocol):
    __slots__ = ()

    @abstractmethod
    def __complex__(self):
        pass


class SupportsAbs(_Protocol[T_co]):
    __slots__ = ()

    @abstractmethod
    def __abs__(self):
        pass


if hasattr(collections_abc, u'Reversible'):

    class Reversible(Iterable[T_co]):
        __slots__ = ()
        __extra__ = collections_abc.Reversible


else:

    class Reversible(_Protocol[T_co]):
        __slots__ = ()

        @abstractmethod
        def __reversed__(self):
            pass


Sized = collections_abc.Sized

class Container(Generic[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Container


class AbstractSet(Sized, Iterable[T_co], Container[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.Set


class MutableSet(AbstractSet[T]):
    __slots__ = ()
    __extra__ = collections_abc.MutableSet


class Mapping(Sized, Iterable[KT], Container[KT], Generic[KT, VT_co]):
    __slots__ = ()
    __extra__ = collections_abc.Mapping


class MutableMapping(Mapping[KT, VT]):
    __slots__ = ()
    __extra__ = collections_abc.MutableMapping


if hasattr(collections_abc, u'Reversible'):

    class Sequence(Sized, Reversible[T_co], Container[T_co]):
        __slots__ = ()
        __extra__ = collections_abc.Sequence


else:

    class Sequence(Sized, Iterable[T_co], Container[T_co]):
        __slots__ = ()
        __extra__ = collections_abc.Sequence


class MutableSequence(Sequence[T]):
    __slots__ = ()
    __extra__ = collections_abc.MutableSequence


class ByteString(Sequence[int]):
    pass


ByteString.register(str)
ByteString.register(bytearray)

class List(list, MutableSequence[T]):
    __slots__ = ()
    __extra__ = list

    def __new__(cls, *args, **kwds):
        if _geqv(cls, List):
            raise TypeError(u'Type List cannot be instantiated; use list() instead')
        return _generic_new(list, cls, *args, **kwds)


class Deque(collections.deque, MutableSequence[T]):
    __slots__ = ()
    __extra__ = collections.deque

    def __new__(cls, *args, **kwds):
        return collections.deque(*args, **kwds) if _geqv(cls, Deque) else _generic_new(collections.deque, cls, *args, **kwds)


class Set(set, MutableSet[T]):
    __slots__ = ()
    __extra__ = set

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Set):
            raise TypeError(u'Type Set cannot be instantiated; use set() instead')
        return _generic_new(set, cls, *args, **kwds)


class FrozenSet(frozenset, AbstractSet[T_co]):
    __slots__ = ()
    __extra__ = frozenset

    def __new__(cls, *args, **kwds):
        if _geqv(cls, FrozenSet):
            raise TypeError(u'Type FrozenSet cannot be instantiated; use frozenset() instead')
        return _generic_new(frozenset, cls, *args, **kwds)


class MappingView(Sized, Iterable[T_co]):
    __slots__ = ()
    __extra__ = collections_abc.MappingView


class KeysView(MappingView[KT], AbstractSet[KT]):
    __slots__ = ()
    __extra__ = collections_abc.KeysView


class ItemsView(MappingView[Tuple[KT, VT_co]], AbstractSet[Tuple[KT, VT_co]], Generic[KT, VT_co]):
    __slots__ = ()
    __extra__ = collections_abc.ItemsView


class ValuesView(MappingView[VT_co]):
    __slots__ = ()
    __extra__ = collections_abc.ValuesView


class ContextManager(Generic[T_co]):
    __slots__ = ()

    def __enter__(self):
        return self

    @abc.abstractmethod
    def __exit__(self, exc_type, exc_value, traceback):
        return None

    @classmethod
    def __subclasshook__(cls, C):
        if cls is ContextManager and any((u'__enter__' in B.__dict__ for B in C.__mro__)):
            if any((u'__exit__' in B.__dict__ for B in C.__mro__)):
                return True
        return NotImplemented


class Dict(dict, MutableMapping[KT, VT]):
    __slots__ = ()
    __extra__ = dict

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Dict):
            raise TypeError(u'Type Dict cannot be instantiated; use dict() instead')
        return _generic_new(dict, cls, *args, **kwds)


class DefaultDict(collections.defaultdict, MutableMapping[KT, VT]):
    __slots__ = ()
    __extra__ = collections.defaultdict

    def __new__(cls, *args, **kwds):
        return collections.defaultdict(*args, **kwds) if _geqv(cls, DefaultDict) else _generic_new(collections.defaultdict, cls, *args, **kwds)


class Counter(collections.Counter, Dict[T, int]):
    __slots__ = ()
    __extra__ = collections.Counter

    def __new__(cls, *args, **kwds):
        return collections.Counter(*args, **kwds) if _geqv(cls, Counter) else _generic_new(collections.Counter, cls, *args, **kwds)


if hasattr(collections_abc, u'Generator'):
    _G_base = collections_abc.Generator
else:
    _G_base = types.GeneratorType

class Generator(Iterator[T_co], Generic[T_co, T_contra, V_co]):
    __slots__ = ()
    __extra__ = _G_base

    def __new__(cls, *args, **kwds):
        if _geqv(cls, Generator):
            raise TypeError(u'Type Generator cannot be instantiated; create a subclass instead')
        return _generic_new(_G_base, cls, *args, **kwds)


CT_co = TypeVar(u'CT_co', covariant=True, bound=type)

class Type(Generic[CT_co]):
    __slots__ = ()
    __extra__ = type


def NamedTuple(typename, fields):
    fields = [ (n, t) for n, t in fields ]
    cls = collections.namedtuple(typename, [ n for n, t in fields ])
    cls._field_types = dict(fields)
    try:
        cls.__module__ = sys._getframe(1).f_globals.get(u'__name__', u'__main__')
    except (AttributeError, ValueError):
        pass

    return cls


def NewType(name, tp):

    def new_type(x):
        return x

    new_type.__name__ = str(name)
    new_type.__supertype__ = tp
    return new_type


Text = unicode
TYPE_CHECKING = False

class IO(Generic[AnyStr]):
    __slots__ = ()

    @abstractproperty
    def mode(self):
        pass

    @abstractproperty
    def name(self):
        pass

    @abstractmethod
    def close(self):
        pass

    @abstractmethod
    def closed(self):
        pass

    @abstractmethod
    def fileno(self):
        pass

    @abstractmethod
    def flush(self):
        pass

    @abstractmethod
    def isatty(self):
        pass

    @abstractmethod
    def read(self, n=-1):
        pass

    @abstractmethod
    def readable(self):
        pass

    @abstractmethod
    def readline(self, limit=-1):
        pass

    @abstractmethod
    def readlines(self, hint=-1):
        pass

    @abstractmethod
    def seek(self, offset, whence=0):
        pass

    @abstractmethod
    def seekable(self):
        pass

    @abstractmethod
    def tell(self):
        pass

    @abstractmethod
    def truncate(self, size=None):
        pass

    @abstractmethod
    def writable(self):
        pass

    @abstractmethod
    def write(self, s):
        pass

    @abstractmethod
    def writelines(self, lines):
        pass

    @abstractmethod
    def __enter__(self):
        pass

    @abstractmethod
    def __exit__(self, type, value, traceback):
        pass


class BinaryIO(IO[bytes]):
    __slots__ = ()

    @abstractmethod
    def write(self, s):
        pass

    @abstractmethod
    def __enter__(self):
        pass


class TextIO(IO[unicode]):
    __slots__ = ()

    @abstractproperty
    def buffer(self):
        pass

    @abstractproperty
    def encoding(self):
        pass

    @abstractproperty
    def errors(self):
        pass

    @abstractproperty
    def line_buffering(self):
        pass

    @abstractproperty
    def newlines(self):
        pass

    @abstractmethod
    def __enter__(self):
        pass


class io(object):
    __all__ = [u'IO', u'TextIO', u'BinaryIO']
    IO = IO
    TextIO = TextIO
    BinaryIO = BinaryIO


io.__name__ = __name__ + '.io'
sys.modules[io.__name__] = io
Pattern = _TypeAlias(u'Pattern', AnyStr, type(stdlib_re.compile(u'')), lambda p: p.pattern)
Match = _TypeAlias(u'Match', AnyStr, type(stdlib_re.match(u'', u'')), lambda m: m.re.pattern)

class re(object):
    __all__ = [u'Pattern', u'Match']
    Pattern = Pattern
    Match = Match


re.__name__ = __name__ + '.re'
sys.modules[re.__name__] = re
